:PROPERTIES:
:ID:       a35b9773-9529-41fd-bbc3-3c2b071047e4
#+PROPERTY: header-args :eval never
:END:
#+title: Django tutorial

* Introduction
We'll build the [[https://github.com/gothinkster/django-realworld-example-app.git][Thinkster's Django RealWorld Example App]] from the ground up. The app is called Conduit and is a Medium clone.

Instead of only building the backend in Django, we'll do both frontend and backend, to show that SSR is still going strong.

We'll be following a simplified version of the [[https://github.com/cookiecutter/cookiecutter-django/][cookiecutter/cookiecutter-django]] architecture (made famous by the excellent book [[https://www.feldroy.com/books/two-scoops-of-django-3-x][Two Scoops of Django 3.x]]), but you don't need to have read it to follow.
* Pre-requisites
** [[https://github.com/DjangoGirls/tutorial][DjangoGirls tutorial]]
You should have followed the [[https://github.com/DjangoGirls/tutorial][DjangoGirls tutorial]] before starting this one: it is excellent for getting you up to speed, and covers most of the introductory material you'll need, like HTML, CSS, and, of course, Django. We'll assume you have completed that tutorial and won't go into the specifics of anything that has already been covered there.
** Python 3.9
** Django 3.2
** Changes compared to django-realworld-example-app
- The =core.TimestampedModel= mostly exists to allow default ordering, which is [[https://docs.djangoproject.com/en/3.2/ref/models/options/#ordering][not recommended]], so we'll do without.
- We can implement the whole app without building a REST API, so we won't.
- Because we don't use REST API, we don't need to implement JWT authentication.
** conda or pyvenv for virtual environments
** git
* Virtual environment
We're working with =conda=, but you can work with =python3-venv=.

#+begin_src shell
conda create --name django
conda activate django
conda install django
#+end_src
* Git
We assume that you know the basics of git. You should =git commit= at the end of every chapter.
* Creating a project
** Project layout
We'll be following the folder structure presented as best practice in /Two Scoops of Django/, which will yield something like the following:

#+begin_src
folder_name
├── config/
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings/
│   ├── urls.py
│   └── wsgi.py
├── project_name/
│   ├── app_1/
│   ├── app_2/
│   ├── static/
│   └── templates/
├── .gitignore
├── manage.py
└── db.sqlite3
#+end_src

Let's create a folder for our project: we'll name it =django_tutorial=.

#+begin_src shell
(django) ~$ mkdir conduit
#+end_src

Let's create our project =conduit=
#+begin_src shell
(django) ~$ cd conduit
(django) django_tutorial$ django-admin startproject conduit .
#+end_src

Our folder structure looks like this now:

#+begin_src
django_tutorial
├── conduit
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── db.sqlite3
└── manage.py
#+end_src

We'll move all the files in the =conduit= folder into the =django_tutorial/config= folder, as we explained above. The project layout should now be:

#+begin_src
.
├── conduit
│── config
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
#+end_src

Because we're deviating from Django's generic project layout, we'll have to update some lines.

You might wonder why we have to fiddle with the settings before even starting to code, but this small effort has the benefit of making the structure of our project easier to understand and of separating the config from the code, which is a good rule of thumb.

In =asgi.py= and =wsgi.py=:

#+begin_src python
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
# from os.environ.setdefault("DJANGO_SETTINGS_MODULE", "conduit.settings")
#+end_src


In =settings.py=:

#+begin_src python
ROOT_URLCONF = "config.urls"
# from ROOT_URLCONF = "conduit.urls"

WSGI_APPLICATION = "config.wsgi.application"
# from WSGI_APPLICATION = "conduit.wsgi.application"
#+end_src
** Database
*** TODO PostgreSQL
Following the arguments of [[https://htmx-django.com/blog/a-minimalistic-modern-django-boilerplate#docker][A Minimalistic Modern Django Boilerplate]]
** App folder structure
Our app will have a lot of moving parts (articles, profiles, tags, etc.). To keep the structure of our app clear, we'll host the logic for each of these parts in separate folders.

We'll build Conduit step by step.
The most basic function that the app should have is the ability to post and read articles. Let's start with that (you'll notice that this part is basically a repeat of Django Girls tutorial's blog app).

#+begin_src shell
(django) django_tutorial$ cd conduit
(django) conduit$ django-admin startapp articles
(django) conduit$ cd articles
#+end_src

Our folder structure now looks like this:

#+begin_src shell
django_tutorial
├── conduit
│   ├── articles
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── __init__.py
│   │   ├── migrations
│   │   │   └── __init__.py
│   │   ├── models.py
│   │   ├── tests.py
│   │   └── views.py
├── config
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── db.sqlite3
└── manage.py
#+end_src

We change the =name= line in the file =apps.py= in the =articles= folder:

#+begin_src python
from django.apps import AppConfig


class ArticlesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'conduit.articles'
#+end_src

We also add the line ='conduit.articles',= to INSTALLED_APPS in =settings.py=:

#+begin_src python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'conduit.articles', # add this line
]
#+end_src
** User model
[[https://docs.djangoproject.com/en/3.0/topics/auth/customizing/#substituting-a-custom-user-model][The Django docs warn you]]: "/If you’re starting a new project, it’s highly recommended to set up a custom user model, even if the default User model is sufficient for you. [...] Changing AUTH_USER_MODEL after you’ve created database tables is significantly more difficult [...]. This change can’t be done automatically and requires manually fixing your schema, moving your data from the old user table, and possibly manually reapplying some migrations./". Scary stuff. Let's just follow the advice.

First, we need to create the app where we'll do everything that has to do with users.

#+begin_src shell
(django) conduit$ django-admin startapp users
#+end_src

We then change the =name= line in the file =apps.py= in the =articles= folder:

#+begin_src python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'conduit.users'
#+end_src

Now, in =users/models.py=, add the following:

#+begin_src python
from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):
    """User model"""

    pass
#+end_src

What we're doing here is take the =AbstractUser= model and save it as is. This way, we can add any modifications we need later on.

# You'll notice that we didn't take the =AbstractUser= model, as explained in the docs. The reason is that the default Django User model (the one we'd be subclassing with =AbstractUser=) has fields that we don't need (=field_name=, =last_name=), etc., while =AbstractBaseUser= is a clean slate.

In =users/models.py= we also need to create a =Profile= model: we'll explain it in more detail later, but suffice it to say that the =Profile= will deal with the everything about our users that is not authentication (logging in and out).

#+begin_src python
class Profile(models.Model):
    """Profile model"""

    user = models.OneToOneField(User)
#+end_src

Now, create a superuser in the terminal, so as to be able to access Django's admin app later on:

#+begin_src shell
(django) django_tutorial$ python manage.py createsuperuser
#+end_src

And one last dark magic trick that you just need to do without asking why (detailed explanations will be provided in a later section, promise): in your terminal, in the =django_tutorial= folder, run the following commands:

#+begin_src
(django) django_tutorial$ python manage.py shell
#+end_src

And once you're in the IPython shell:

#+begin_src python
Python 3.9.7 | packaged by conda-forge | (default, Sep 29 2021, 19:20:46)
Type 'copyright', 'credits' or 'license' for more information
IPython 7.30.1 -- An enhanced Interactive Python. Type '?' for help.

In [1]: from conduit.users.models import User, Profile

In [2]: user = User.objects.get(username='admin')

In [3]: user.profile = Profile.objects.create(user=user)
#+end_src

Finally, we need to tell Django that we're not using the default User model. In =settings.py=, add your =users= app to =INSTALLED_APPS= and point =AUTH_USER_MODEL= to it:

#+begin_src python
# other settings

INSTALLED_APPS = [
    # other apps
    'conduit.users'                  # new
]

AUTH_USER_MODEL = 'users.User'    # new
#+end_src
** Create a database
Make the migrations and start the server:

#+begin_src shell
(django) django_tutorial$ python manage.py makemigrations
(django) django_tutorial$ python manage.py migrate
(django) django_tutorial$ python manage.py runserver
#+end_src

Our app, Conduit, is online!
* Article model
** Model
We'll start by making a model for our articles.
The articles need a title, a body (the text), a description, an author, and a creation date.

#+begin_src python
from django.db import models
from django.conf import settings


class Article(models.Model):
    title = models.CharField(db_index=True, max_length=255)
    description = models.TextField(max_length=2000)
    body = models.TextField()
    author = models.ForeignKey(
        "users.Profile",
        on_delete=models.CASCADE,
        related_name="articles",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse("article_detail", kwargs={"pk": self.pk})
#+end_src

The =ForeignKey= allows us to have multiple articles for every user.
=on_delete=models.CASCADE) means that the article will be deleted if the user is deleted.
=related_name="articles"= allows us to access a user's articles through an =articles= attribute.

Let's sync the database again:

#+begin_src shell
(django) django_tutorial$ python manage.py makemigrations
(django) django_tutorial$ python manage.py migrate
#+end_src
** Django admin
In order to have something to work with for the rest of the tutorial, we need to create some posts. Because we can't yet do it through Conduit, we will do so through Django admin.

First, register the =Article= model in =articles/admin.py= by adding the following line:

#+begin_src python
from django.contrib import admin
from .models import Article

admin.site.register(Article)            # new
#+end_src

The server should still be running (otherwise restart it). Log in as the superuser you just created and create 3 articles.
* Lists of Articles
** Home view
The default view that the unauthenticated user has is the global feed, or the list of all articles.

We add the following line in =django_tutorial/conduit/urls.py=, so that the project-level =urls.py= is aware of the urls defined in =articles/urls.py=:

#+begin_src python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('conduit.articles.urls')),                         #new
]
#+end_src

Let's create a =urls.py= file in the =articles= folder, and add the following:

#+begin_src python
from django.urls import path
from . import views

urlpatterns = [path("", Home.as_view(), name="home")]
#+end_src

In =views.py=, we add the following:

#+begin_src python
from django.shortcuts import render
from .models import Article


class Home(TemplateView):
    """all published articles"""

    template_name = "home.html"

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["articles"] = Article.objects.order_by("-created_at")
        return context
#+end_src
** Templates folder
We need a template now, but before this we need to create a folder for templates and for static files (icons, CSS, etc.).

It's easier to have all templates in one place, instead of in each separate app, and the same is true for static files. Let's create the =templates= and =static= folders:

#+begin_src shell
(django) conduit$ mkdir templates
(django) conduit$ mkdir static
#+end_src

We need to modify =settings.py= so Django is aware of our project's architecture.
Let's define the APPS_DIR below BASE_DIR first:

#+begin_src python
BASE_DIR = Path(__file__).resolve().parent.parent
APPS_DIR = BASE_DIR / "conduit"
#+end_src

Let's change the =DIRS= line in the =TEMPLATES= section in =settings.py= like this:

#+begin_src python
"DIRS": [APPS_DIR / "templates"], # changed from "DIRS": []
#+end_src

Similarly, let's define the =STATIC_ROOT= directory below the =STATIC= line like this:

#+begin_src python
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [APPS_DIR / "static"]
#+end_src

** Base template
Let's create the base template now.

#+begin_src shell
(django) conduit$ touch templates/base.html
#+end_src

This template will contain the following:

#+begin_src html
<!doctype html>
{% load static %}
<html lang="en">
    <head>
        <meta charset="utf-8">
        <link rel="icon" href="{%  static '/icons/favicon.ico' %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- favicon -->
        <!-- Thinkster's CSS -->
        <link rel="stylesheet" href="//demo.productionready.io/main.css">
        <!-- icons for later -->
        <link href="//code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css" rel="stylesheet" type="text/css">
        <!-- fonts -->
        <link href="//fonts.googleapis.com/css?family=Titillium+Web:700|Source+Serif+Pro:400,700|Merriweather+Sans:400,700|Source+Sans+Pro:400,300,600,700,300italic,400italic,600italic,700italic&display=swap" rel="stylesheet" type="text/css">
        {% block title %}
            <title>Conduit: Django + HTMX</title>
        {% endblock %}
    </head>
    <body>
        <main>
            {% block content %}
            {% endblock %}
        </main>
    </body>
</html>
#+end_src

We'll also download the favicon referenced in our template: download the file located at the URL below to =conduit/articles/static/icons/favicon.ico=:
https://github.com/gothinkster/react-redux-realworld-example-app/blob/master/public/favicon.ico
** Home template
Now we'll make the =home.html= template, which for now only needs to display our "global feed".
# Because we know that there will be a lot stuff contained in view later ("Your feed", tag feed, "Popular tags"), we might as well take that into account and make our templates as modular as possible.
Let's create the template  and add the following to it:

#+begin_src html
{% extends 'base.html' %}
{% block content %}
    <div class="home-page">
        <div class="banner">
            <div class="container">
                <h1 class="logo-font">conduit</h1>
                <p>A place to share your knowledge.</p>
            </div>
        </div>
        <div class="container page">
            <div class="row">
                <div class="col-md-9">
                    {% for article in articles %}
                        <div class="article-preview">
                            <div class="article-meta">
                                <div class="info">
                                    <span class="author">
                                        {{ article.author.user.username }}
                                    </span>
                                    <span class="date">
                                        {{ article.created_at|date:"D M d Y" }}
                                    </span>
                                </div>
                            </div>
                            <a href="{{ article.get_absolute_url }}" rel="prefetch" class="preview-link">
                                <h1>{{ article.title }}</h1>
                                <p>{{ article.description }}</p>
                                <span>Read more...</span>
                            </a>
                        </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src

The HTML is adapted from other realworld projects (especially the [[https://github.com/sveltejs/realworld/][SvelteKit implementation of the RealWorld app]], because Svelte is unexpectedly close to Django's templating language).
Because the HTML is little more than a copy-paste, we won't explain its structure and classes: suffice it to say that this is required to have something that looks like the actual Realworld app.

#+ATTR_ORG: :width 400
[[./Screenshots/home - global feed.png]]
[[./Screenshots/home - global feed - realworld.png]]

It's starting to look like something, but we can improve the template a bit.

We want to keep our templates as modular as possible, to simplify the structure of our project and make it easier to think about. In this case, we could move the =<div class="article-preview">= to a separate file. Let's move all the code in the ={% for article in articles %}= for loop into the file =article_preview.html= (which we need to create).

In =templates/home.html=, we change the following lines:

#+begin_src html
<div class="container page">
  <div class="row">
    <div class="col-md-9">
      {% for article in articles %}
        {% include 'article_preview.html' %} <!-- from <div class="article-preview">...</div>-->
      {% endfor %}
    </div>
  </div>
</div>
#+end_src

Our =templates/article_preview.html= file should look like this:

#+begin_src html
{% block content %}
  <div class="article-preview">
    <div class="article-meta">
      <div class="info">
        <span class="author">
          {{ article.author.user.username }}
        </span>
        <span class="date">
          {{ article.created_at|date:"D M d Y" }}
        </span>
      </div>
    </div>
    <a href="{{ article.get_absolute_url }}" rel="prefetch" class="preview-link">
      <h1>{{ article.title }}</h1>
      <p>{{ article.description }}</p>
      <span>Read more...</span>
    </a>
  </div>
{% endblock %}
#+end_src
* Article views, templates, etc.
** Article view
Next we'll implement the article view.

We'll be working with Class-Based Views: the /Django Girls/ tutorial only presents Function-Based Views, which are arguably a more intuitive option, but CBVs are considered to be best practice, at least according to /Two Scoops of Django/, and simplify a lot of work.

First, we create a view in =views.py=:

#+begin_src python
from django.views.generic import TemplateView, DetailView


class ArticleDetailView(DetailView):
    """detail view for individual articles"""

    model = Article
    template_name = "article_detail.html"
#+end_src

Then, we modify the =articles/urls.py= file:

#+begin_src python
from .views import Home, ArticleDetailView

urlpatterns = [
    path("", Home.as_view(), name="home"),
    path("article/<int:pk>", ArticleDetailView.as_view(), name="article_detail"),
]
#+end_src

*** TODO create "article_list.html", {% include 'article_list.html' with tab=tab %}
** Article template
Now, we create the =article_detail.html= file in our =templates= folder and add the following to it:

#+begin_src html
{% extends 'base.html' %}
{% block title %}
    <title>{{ article.title }} - Conduit: Django + HTMX</title>
{% endblock %}
{% block content %}
    <div class="article-page">
        <div class="banner">
            <div class="container">
                <h1>{{ article.title }}</h1>
                <div class="article-meta">
                    <div class="info">
                        <span class="author">
                            {{ article.author.user.username }}
                        </span>
                        <span class="date">
                            {{ article.created_at|date:"D M d Y" }}
                        </span>
                    </div>
                </div>
            </div>
        </div>
        <div class="container page">
            <div class="row article-content">
                <div class="col-xs-12">
                    <div>
                        {{ article.body|linebreaks }}
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src

Finally, we modify =home.html= so that article previews redirect to articles:

#+begin_src html
...
<a href="{{ article.get_absolute_url }}" rel="prefetch" class="preview-link">   <!-- new -->
   <h1>{{ article.title }}</h1>
   <p>{{ article.description }}</p>
   <span>Read more...</span>
</a>                                                                            <!-- new -->
...
#+end_src

Let's see what it looks like:

#+ATTR_ORG: :width 400
[[./Screenshots/article_detail.png]]
[[./Screenshots/article_detail - realworld.png]]

** Slugs
We want our article URLs to include slugs, which are easier to read than IDs.

We want the slugs to be unique, but some articles might have the same titles, which would generate the same slugs. One solution to this problem is to combine slugs with UUIDs.

*** Defining a slug and a UUID in the model
First, we need to modify our =Article= model to include a slug, and to update the =get_absolute_url= method:

#+begin_src python
class Article(models.Model):
    # ...
    slug = models.SlugField(max_length=255, editable=False)             # new
    uuid_field = models.UUIDField(default=uuid.uuid4, editable=False)   # new

    # ...
    def get_absolute_url(self):
        return reverse("article_detail", kwargs={"slug": self.slug})    # new

#+end_src

After modifying the model, we need to sync the database, but this will return a warning.

#+begin_src shell
(django) django_tutorial$ python manage.py makemigrations
You are trying to add a non-nullable field 'slug' to article without a default; we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit, and let me add a default in models.py
Select an option:
#+end_src

We can't select =1= because a default is by definition non-unique. We select =2= to abort and add the =null=True= arg to the slug field, so as to be able to migrate and then modify the slug manually through the Django admin app:

#+begin_src python
class Article(models.Model):
    # ...
    slug = models.SlugField(max_length=100, null=True)
    # ...
#+end_src

We then run =makemigrations= and =migrate=, then set a unique slug for each =Article= through the Django admin app manually. Once we're done, we remove the =null=True= arg and add the =editable=False= arg:

#+begin_src python
class Article(models.Model):
    # ...
    slug = models.SlugField(max_length=255, editable=False)             # new
    # ...
#+end_src

When we migrate, we get a warning:

#+begin_src
(django) django_tutorial$ python manage.py makemigrations
You are trying to change the nullable field 'slug' on article to non-nullable without a default; we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Ignore for now, and let me handle existing rows with NULL myself (e.g. because you added a RunPython or RunSQL operation to handle NULL values in a previous data migration)
 3) Quit, and let me add a default in models.py
Select an option:
#+end_src

You can safely select =2=, as we already have taken care of the slug fields through the Django admin app.
*** Generate unique slug automatically
We want to avoid manually entering the slugs for every article: the generation of a unique slug should be triggered automatically every time an Article is saved.

Let's create a =utils.py= file in the =conduit= folder and add the following methods to it:

#+begin_src python
from django.utils.text import slugify
import uuid

def unique_slug_generator(instance):
    """generate a unique slug for Articles from the title and a UUID"""

    ArticleClass = instance.__class__

    # get max length of =slug= as defined in the Article model
    max_length = ArticleClass._meta.get_field('slug').max_length

    # create slug_uuid by concatenating slugified title and UUID
    slug = "{slug_field}-{uuid_field}".format(
        slug_field = slugify(instance.title)[:max_length-36-1],
        uuid_field = str(instance.uuid_field)
    )

    # if the slug exists, make another one
    if ArticleClass.objects.filter(slug=slug).exists():
        return unique_slug_generator(instance)

    return slug
#+end_src
*** Signals
We will now use a signal, a Django utility that allows linking events with actions, to call our =unique_slug_generator= every time an Article is created. We could override the =Article= model's =save= method instead: this is a common method, but not [[https://teddit.ggc-project.de/r/django/comments/p3pgr/overriding_save_vs_presave_signals_which_is/][best practice]].

We create a =signals.py= file in =articles/= and add the following method to it:

#+begin_src python
from django.db.models.signals import pre_save
from django.dispatch import receiver
from .models import Article
from config.utils import unique_slug_generator

@receiver(pre_save, sender=Article)
def pre_save_receiver(sender, instance, *args, **kwargs):
   if not instance.slug:
       instance.slug = unique_slug_generator(instance)
#+end_src

In order to activate this signal, we will modify =articles/apps.py=:

#+begin_src
from django.apps import AppConfig


class ArticlesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "conduit.articles"

    def ready(self):                                # new
        import conduit.articles.signals             # new
#+end_src

Let's also change our =urlpatterns= in =articles/urls.py=:

#+begin_src python
# other imports
from .views import Home, ArticleDetailView

urlpatterns = [
    # other paths
    path("article/<slug:slug>", ArticleDetailView.as_view(), name="article_detail"),
]
#+end_src

Let's try creating an Article through the Django admin app.

When going back to http://localhost:8000/ (where your app is running), you will see that your new article has a slug consisting of its slugified title and a UUID:

#+ATTR_ORG: :width 400
[[./Screenshots/article_detail - slug.png]]
*** TODO add =primary_key=True= to =uuid_field=, then add =query_pk_and_slug=True= in relevant views
* Navbar
Let's create a simple navigation bar. Because we have yet to implement authentication and profiles, the navbar will just contain a link to =Home=.

Let's add the following lines to =base.html=:

#+begin_src html
    <body>
        <!-- navbar -->                     <!-- new -->
        {% include 'nav.html' %}            <!-- new -->
        <main>
            {% block content %}
            {% endblock %}
        </main>
#+end_src

Let's create =nav.html= in out =templates= folder and add the following to it:

#+begin_src html
<nav class="navbar navbar-light">
    <div class="container">
        <a rel="prefetch" class="navbar-brand" href="/">conduit</a>
        <ul class="nav navbar-nav pull-xs-right">
            <li class="nav-item">
                <a rel="prefetch" class="nav-link" href="{% url 'home' %}">
                    Home
                </a>
            </li>
        </ul>
    </div>
</nav>
#+end_src
* Creating, editing, and deleting Articles
We have implemented the features that allow to view articles, but we need to allow users to create, edit, and delete them as well. We'll first implement this functionality, and modify it later to take into account user authentication.
** Creating Articles
Let's allow users to create articles.

We define the =EditorCreateView= view in =views.py=:

#+begin_src python
# other imports
from django.views.generic import (
     # other views
     CreateView
)

# other views

class EditorCreateView(CreateView):
    """create article"""

    model = Article
    fields = ['title', 'description', 'body']
    template_name = "editor.html"
#+end_src

We add the following to =urls.py=:

#+begin_src python
# other imports
from .views import Home, ArticleDetailView, EditorCreateView

urlpatterns = [
    # other paths
    path("editor", EditorCreateView.as_view(), name="editor_create"),
]
#+end_src

We add a =New article= button to the Nav bar in =nav.html=:

#+begin_src html
        <ul class="nav navbar-nav pull-xs-right">
            <li class="nav-item">
                <a rel="prefetch" class="nav-link" href="{% url 'home' %}">
                    Home
                </a>
            </li>
            <li class="nav-item">                                                       <!-- new -->
                <a rel="prefetch" href="{% url 'editor_create' %}" class="nav-link">    <!-- new -->
                    <span class="ion-compose"> New Post </span>                            <!-- new -->
                </a>                                                                    <!-- new -->
            </li>                                                                       <!-- new -->
        </ul>
#+end_src

Now, we can create the template =editor.html=:

#+begin_src html
{% extends 'base.html' %}
{% block title %}
    <title>Editor - Conduit: Django + HTMX</title>
{% endblock %}
{% block content %}
    <div class="editor-page">
        <div class="container page">
            <div class="row">
                <div class="col-md-10 offset-md-1 col-xs-12">
                    <form method="post">
                        {% csrf_token %}
                        {{ form.non_field_errors }}
                        <fieldset>
                            {% form.non_field_errors %}
                            <fieldset class="form-group">
                                <input
                                    class="form-control form-control-lg"
                                    type="text"
                                    placeholder="Article Title"
                                    name='title'
                                />
                            </fieldset>
                            {{ form.title.errors }}
                            <fieldset class="form-group">
                                <input
                                    class="form-control"
                                    type="text"
                                    placeholder="What's this article about?"
                                    name='description'
                                />
                            </fieldset>
                            {{ form.description.errors }}
                            <fieldset class="form-group">
                                <textarea
                                    class="form-control"
                                    rows="8"
                                    placeholder="Write your article (in markdown)"
                                    name='body'
                                ></textarea>
                            </fieldset>
                            {{ form.body.errors }}
                            <button class="btn btn-lg pull-xs-right btn-primary">
                                Publish Article
                            </button>
                        </fieldset>
                    </form>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src

Try to create an article in your app. When you hit "Publish", you'll get an error:

#+begin_src
IntegrityError at /editor
NOT NULL constraint failed: articles_article.author_id
#+end_src

That's because the form doesn't know who the author is, and author is a required field in our model.
Let's override the =EditorCreateView= view's =form_valid= method in our =views.py= file: before we save the form, we'll set the logged in user (=admin=, for now) as the =author=:

#+begin_src python
class EditorCreateView(CreateView):
    """create article"""

    model = Article
    fields = ["title", "description", "body"]
    template_name = "editor.html"

    def form_valid(self, form):                         # new
        self.object = form.save(commit=False)           # new
        self.object.author = self.request.user.profile  # new
        self.object.save()                              # new
        return super().form_valid(form)                 # new
#+end_src

Once this is done, try creating another article: it should work.
** Editing Articles
We will now implement the editing feature.

In =views.py=, add the following:

#+begin_src python
# other imports
from django.views.generic import (
    # other views
    UpdateView,
)

# other views

class EditorUpdateView(UpdateView):
    """edit article"""

    model = Article
    fields = ["title", "description", "title"]
    template_name = "editor.html"
#+end_src

We're using the same template for creating and editing articles.
In =urls.py=, add:

#+begin_src python
# other imports
from .views import (
    # other views
    EditorUpdateView
)

urlpatterns = [
    # other paths
    path("editor/<slug:slug>", EditorUpdateView.as_view(), name="editor_update"),
]
#+end_src

In =article_detail.html=, we add a button for editing the article and pass =article.slug= as an argument to the url (see [[https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#url][the documentation for =url= tag]]), given that our URL expects a slug (=editor/<slug:slug>=). The documentation for ):

#+begin_src python
                <div class="article-meta">
                    <div class="info">
                        <span class="author">
                            {{ article.author }}
                        </span>
                        <span class="date">
                            {{ article.created_at|date:"F d, Y" }}
                        </span>
                    </div>
                    <span>                                                              <!-- new -->
                        <a                                                              <!-- new -->
                            href="{% url 'editor_update' slug=article.slug %}"          <!-- new -->
                            class="btn btn-outline-secondary btn-sm"                    <!-- new -->
                        >                                                               <!-- new -->
                            <span class="ion-edit">                                    <!-- new -->
                                Edit Article                                            <!-- new -->
                            </span>                                                    <!-- new -->
                        </a>                                                            <!-- new -->
                    </span>                                                             <!-- new -->
                </div>
#+end_src

In the =editor.html= template, we want to have the form fields prepopulated with the relevant values. When using =UpdateView=, we have access to the object being updated. Let's add the following to the =editor.html= template:

#+begin_src html
                        <fieldset>
                            <fieldset class="form-group">
                                <input
                                    class="form-control form-control-lg"
                                    type="text"
                                    placeholder="Article Title"
                                    name="title"
                                    value="{{ article.title|default_if_none:'' }}"          <!-- new -->
                                />
                            </fieldset>
                            <fieldset class="form-group">
                                <input
                                    class="form-control"
                                    type="text"
                                    placeholder="What's this article about?"
                                    name="description"
                                    value="{{ article.description|default_if_none:'' }}"    <!-- new -->
                                />
                            </fieldset>
                            <fieldset class="form-group">
                                <textarea
                                    class="form-control"
                                    rows="8"
                                    placeholder="Write your article (in markdown)"
                                    name="body"
                                />{{ article.body|default_if_none:'' }}</textarea>          <!-- new -->
                            </fieldset>
                            <button class="btn btn-lg pull-xs-right btn-primary">
                                Publish Article
                            </button>
                        </fieldset>
#+end_src

Try editing an article: all the values should be prepopulated.
** Deleting Articles
In =views.py=, we create a =ArticleDeleteView=:

#+begin_src python
# other imports
from django.views.generic import (
    # other views
    DeleteView,
)
from django.urls import reverse_lazy

# other classes
class EditorDeleteView(DeleteView):
    """delete article"""

    model = Article
    success_url = reverse_lazy("home")
    template_name = "article_detail.html"
#+end_src

Notice that we're using the =article_detail.html= template. We could use a separate one, but that would require to load a new page, which seems unnecessary: we'll in a second how we're making this work.

In =urls.py=:

#+begin_src python
# other imports
from .views import (
    # other views
    EditorDeleteView,
)

urlpatterns = [
    # other paths
    path("editor/<slug:slug>/delete", EditorDeleteView.as_view(), name="editor_delete"),
]
#+end_src

Now, create an =article_delete.html= file: this will hold the form for deleteing the article.

#+begin_src html
<form                                                                                       <!-- new  -->
    method="POST"                                                                           <!-- new  -->
    action="{% url 'editor_delete' slug=article.slug %}"                                    <!-- new  -->
    style="display:inline"                                                                  <!-- new  -->
>                                                                                           <!-- new  -->
    {% csrf_token %}                                                                        <!-- new  -->
    <button                                                                                 <!-- new  -->
        class="btn btn-outline-danger btn-sm"                                               <!-- new  -->
        value="DELETE"                                                                      <!-- new  -->
        onclick="return confirm('Are you sure you want to delete {{ article.title }}?')"    <!-- new  -->
    >                                                                                       <!-- new  -->
        <span class="ion-trash-a">                                                         <!-- new  -->
            Delete Article                                                                  <!-- new  -->
        </span>                                                                                <!-- new  -->
    </button>                                                                               <!-- new  -->
</form>                                                                                     <!-- new  -->
#+end_src

Now, we want to load this template in =article_detail.html= directly, which we achieve with an =include= tag:

#+begin_src html
<span>
    <a
        href="{% url 'editor_update' slug=article.slug %}"
        class="btn btn-outline-secondary btn-sm"
    >
        <i class="ion-edit">
            Edit Article
        </i>
    </a>
    {% include 'article_delete.html' %}             <!-- new -->
</span>
#+end_src

Try deleting an article: you should get a nice confirmation message while still on the =article_detail.html= template, before the article is deleted.
* Comments
Now that we have articles, we need comments.
** Model
A comment needs a related article, an author, a body, and a date.
Let's create a =Comment= model in =models.py=:

#+begin_src python
# other models

class Comment(models.Model):
    article = models.ForeignKey(
        Article,
        on_delete=models.CASCADE,
        related_name="comments",
        to_field="slug",
    )
    body = models.TextField()
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="comments",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.body[:60] + "..."

    def get_absolute_url(self):
        return reverse("article_detail", kwargs={"slug": self.article.slug})
#+end_src

Let's =makemigrations= and =migrate=. You should get the following error:

#+begin_src
SystemCheckError: System check identified some issues:

ERRORS:
articles.Comment.article: (fields.E311) 'Article.slug' must be unique because it is referenced by a foreign key.
        HINT: Add unique=True to this field or add a UniqueConstraint (without condition) in the model Meta.constraints.
#+end_src

That's because we're using articles' slugs as ForeignKeys for the comments (so that we can filter our comments by the attached articles' slugs instead of their UUIDs). This error is easily corrected by adding =unique=True= as an argument to the =slug= field in the =Article= model in =models.py=. You should be able to =makemigrations= and =migrate= after that.

Now, we need to register our model in =admin.py=:

#+begin_src python
from django.contrib import admin
from .models import Article, Comment        # new

admin.site.register(Article)
admin.site.register(Comment)                # new
#+end_src

When this is done, go to your admin app and create a few comments for a couple articles.
** Viewing comments
We want to be able to view the comments in our =article_detail.html= template.

In =article_detail.html=:

#+begin_src html
<div class="container page">
    <div class="row article-content">
        <div class="col-xs-12">
            <div>
                {{ article.body|linebreaks }}
            </div>
        </div>
    </div>
    <hr />                                  <!-- new -->
    <div class="row">                       <!-- new -->
        {% include 'comments.html' %}       <!-- new -->
    </div>                                  <!-- new -->
</div>
#+end_src

Now create =comments.html= in the =templates= folder and add the following:

#+begin_src html
<div class="col-xs-12 col-md-8 offset-md-2">
    {% for comment in article.comments.all|dictsortreversed:'created_at' %}
        <div class="card">
            <div class="card-block">
                <p class="card-text">
                    {{ comment.body }}
                </p>
            </div>
            <div class="card-footer">
                <span class="comment-author">
                    {{ comment.author.user.username }}
                </span>
                <span class="date-posted">
                    {{ comment.created_at|date:"D M d Y" }}
                </span>
            </div>
        </div>
    {% endfor %}
</div>
#+end_src
** Creating comments
We will now start allowing our users to leave comments on the website. We could do this like in the Django Girls tutorial: the =ArticleDetailView= would include a button that would direct to =CommentCreateView= on a separate page, and saving the comment would bring the user back to the =ArticleDetailView=. However, the =RealWorldApp= allows users to create and save their comments directly below the article, on the same page, so that's what we're going to try.

Surprisingly, this is not straightforward to implement in Django, because it implies mixing =DetailView= and =CreateView= functionalities in a single page, which is made difficult by the fact that the =DetailView= doesn't have a POST method, while the =CreateView= requires it. Fortunately, our use case is covered in the Django documentation: https://docs.djangoproject.com/en/4.0/topics/class-based-views/mixins/#an-alternative-better-solution.

First, we'll create a =CommentCreateView= in =views.py=.
We override the =form_valid= method because we need to specify the =author= and =article= fields required by the =Comment= model.
We also override the =get_success_url= because we want the user to be redirected to the =ArticleDetailView= upon saving the comment.

#+begin_src python
# other imports
from .models import Article, Comment

# other models
class CommentCreateView(CreateView):
    """create comment"""

    model = Comment
    fields = ["body"]
    template_name = "article_detail.html"

    def form_valid(self, form):
        form.instance.author = self.request.user.profile
        form.instance.article = Article.objects.filter(
            slug=self.kwargs.get("slug")
        ).first()
        return super().form_valid(form)

    def get_success_url(self):
        return reverse("article_detail", kwargs={"slug": self.object.article.slug})
#+end_src

Now, we need to modify the =ArticleDetailView= to make the =CommentCreateView='s form available to the template =article_detail.html= through the =get_context_data= method:

#+begin_src python
class ArticleDetailView(DetailView):
    """detail view for individual articles"""

    model = Article
    template_name = "article_detail.html"

    def get_context_data(self, **kwargs):                   # new
        context = super().get_context_data(**kwargs)        # new
        context["form"] = CommentCreateView().get_form()    # new
        return context                                      # new
#+end_src

Finally, we create a view that combines =ArticleDetailView= and =CommentCreateView=:

#+begin_src python
# other imports
from django.views.generic import (
    # other views
    View,
)


# other models

class ArticleCommentView(View):
    """view article and post comments"""

    def get(self, request, *args, **kwargs):
        view = ArticleDetailView.as_view()
        return view(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        view = CommentCreateView.as_view()
        return view(request, *args, **kwargs)
#+end_src

We want this new hybrid view to be the one returned by the =article/<slug:slug>= path: depending on whether the method is =GET= or =POST=, the new view will either return the =ArticleDetailView=, or the =CommentCreateView=.

In =urls.py=, we replace the =article_detail= path by the following:

#+begin_src python
# other imports
from .views import (
    # other views
    ArticleCommentView,
)

urlpatterns = [
    # other paths
    path(
        "article/<slug:slug>",
        ArticleCommentView.as_view(),
        name="article_detail",
    ),
    # instead of =path("article/<slug:slug>", ArticleCommentView.as_view(), name="article_detail")=
]
#+end_src

Now that our views.py and urls.py are ready, we need to create the templates.

Create =comment_create.html=, which corresponds to the =CommentCreateView='s form:

#+begin_src html
{% block content %}
    <form
        class="card comment-form"
        method="post"
        action="{% url 'article_detail' slug=object.slug %}"
    >
        {% csrf_token %}
        <div class="card-block">
            <textarea
                class="form-control"
                rows="3"
                placeholder="Write a comment..."
                name="{{ form.body.name }}"
            >{{ form.body.value|default_if_none:'' }}</textarea>
        </div>
        <div class="card-footer">
            <button class="btn btn-sm btn-primary" type="submit">
                Post Comment
            </button>
        </div>
    </form>
{% endblock %}
#+end_src

In =comments.html=, we include the =comment_create.html= template:

#+begin_src html
<div class="col-xs-12 col-md-8 offset-md-2">
    <div>                                           <!-- new -->
        {% include 'comment_create.html' %}         <!-- new -->
    </div>                                          <!-- new -->
    {% for comment in article.comments.all|dictsortreversed:'created_at' %}
    <!-- ... -->
#+end_src

Everything should be working now. Try to create some comments on an article.
** Deleting comments
We now want to be able to delete comments.

In =views.py=, add the =CommentDeleteView=:

#+begin_src python
class CommentDeleteView(DeleteView):
    """delete comment"""

    model = Comment
    template_name = "article_detail.html"

    # redirect to attached article's detail page upon success
    def get_success_url(self):
        return reverse("article_detail", kwargs={"slug": self.object.article.slug})
#+end_src

In =urls.py=:

#+begin_src python
urlpatterns = [
    # ...
    path(
        "article/<slug:slug>/comment/<int:pk>/delete",
        CommentDeleteView.as_view(),
        name="comment_delete",
    ),
]
#+end_src

We require =pk= as an argument because that's what the =CommentDeleteView= needs to know which comment to delete. The =<slug:slug>= part is unnecessary, but it makes the path more logical, I find.

In =comments.html=:

#+begin_src html
<div class="card-footer">
    <span class="comment-author">
        {{ comment.author }}
    </span>
    <span class="date-posted">
        {{ comment.created_at|date:«D M d Y» }}
    </span>
    {% include 'comment_delete.html' %}             <!-- new -->
</div>
#+end_src

Create =comment_delete.html=:

#+begin_src html
{% block content %}
    <form
        method="post"
        action="{% url 'comment_delete' slug=article.slug pk=comment.pk %}"
        class="mod-options"
    >
        {% csrf_token %}
        <button
            style="background: none;
                   border: none;
                   padding: 0;
                   margin: 0;
                   font-size: inherit;
                   margin-left: 5px;
                   opacity: 0.6;
                   cursor: pointer;"
            value="DELETE"
            class="ion-trash-a"
        ></button>
    </form>
{% endblock %}
#+end_src
* Users and Profiles
Time to work on our users and profiles.

[[https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#specifying-a-custom-user-model][The Django docs say]] "/it may be more suitable to store app-specific user information in a model that has a relation with your custom user model. That allows each app to specify its own user data requirements without potentially conflicting or breaking assumptions by other apps. It also means that you would keep your user model as simple as possible, focused on authentication, and following the minimum requirements Django expects custom user models to meet./".

This is why we'll have the authentication logic in a =User= model and the profile logic in a =Profile= model.
** User model
*** User
The =User= model will contain everything related to authentication.

We need an email, a username, and a password. Let's add the following to the =User= model in =users/models.py=:

#+begin_src python
from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):
    """User model"""

    username = models.CharField(max_length=255, unique=True)
    email = models.EmailField(unique=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["username"]

    def __str__(self):
        self.email
#+end_src

The =username= field is the unique human-readable identifier that we can represent users with in our app.
The =email= field holds the email users will be logging in with. We specify this in =USERNAME_FIELD=.
The =password= field is already provided by =AbstractUser=.
=REQUIRED_FIELDS= is the list of field users will be prompted for at sign up: because the =USERNAME_FIELD= and the =password= are already required by Django, we only need to specify =username=.
More information about the fields can be found in the docs for [[https://docs.djangoproject.com/en/4.0/ref/contrib/auth/][the default Django User model]].
*** UserManager
We also need a =UserManager=, [[https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#writing-a-manager-for-a-custom-user-model][as advised by the docs]]. In =models.py=, we add the following, BEFORE we define our =User= model:

#+begin_src python
# other imports
from django.contrib.auth.models import AbstractUser, UserManager

# other models
class CustomUserManager(UserManager):
    """custom UserManager with unique identifier is email instead of username"""

    def create_user(self, username, email, password=None):
        """Create and return a User with username, email, and password"""

        if email is None:
            raise ValueError("Email is required.")
        if username is None:
            raise ValueError("Username is required")

        email = self.normalize_email(email)
        user = self.model(username=username, email=email)
        user.set_password(password)
        user.save()

        return user

    def create_superuser(self, username, email, password=None):
        """Create and return a SuperUser with admin permissions."""

        user = self.create_user(username, email, password)
        user.is_staff = True
        user.is_superuser = True
        user.is_active = True
        user.save()

        return user
#+end_src

=create_user= and =create_superuser= are self-explanatory.

We now need to go back to the =User= model in =users/models.py= and indicate to Django that the =UserManager= defined above will manage objects of type =User=:

#+begin_src python
# other
class User(AbstractUser):
    """User model"""

    username = models.CharField(max_length=255, unique=True)
    email = models.EmailField(unique=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["username"]

    objects = CustomUserManager()               # new

    def __str__(self):
        return self.email
#+end_src

Make sure to =makemigrations= and =migrate=, so that Django is aware of your new model.
*** admin.py
We need to register this new =User= model in =users/admins.py=, to have access to it in our admin app.

#+begin_src python
from django.contrib import admin
from .models import User

admin.site.register(User)
#+end_src

You'll notice that this code is much shorter than [[https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#extending-the-existing-user-model][what the docs say]]: we're trying to keep it simple, so we'll do without some of the quality of life improvements that a more intricate code would allow.
** Profile model
*** Profile
We are following the instructions in the Django docs about [[https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#extending-the-existing-user-model][extending a User model]]. We need to store some information about our users in the database, so we'll create a model that will link to the =User= through a =OneToOneField=.

Our =Profile= needs the following fields:
- image
- bio
- articles
- comments

We have already taken care of the two last fields in the =Article= and =Comment= models through the =related_name= args in the =author= fields.

We will allow users to specify a URL to their avatar and to write a short bio. This is optional, so we make sure to have =blank=True=. Let's add the following to the =Profile= model in =users/models.py=:

#+begin_src python
class Profile(models.Model):
    """Profile model"""

    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    image = models.URLField(
        default="https://static.productionready.io/images/smiley-cyrus.jpg"
    )
    bio = models.TextField(max_length=1000, blank=True)

    def __str__(self):
        return self.user.username
#+end_src

As always, whenever you change a model, you should =makemigrations= and =migrate=.
*** signals.py
Since we're defining the =Profile= outside of the =User= model, a profile won't be created automatically whenever a user signs up.

Let's follow the docs linked above and code up a signal that creates a =Profile= at user sign-up.

Create a =signals.py= file in the =users= folder and add the following:

#+begin_src python
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import User, Profile


@receiver(post_save, sender=User)
def create_profile_for_user(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)


@receiver(post_save, sender=User)
def save_profile_for_user(sender, instance, **kwargs):
    instance.profile.save()
#+end_src

In order to activate this signal, we will modify =users/apps.py=:

#+begin_src python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "conduit.users"

    def ready(self):                        # new
        import conduit.users.signals        # new
#+end_src

This signal runs whenever a =User= is saved. By checking for =created=, we make sure to only initiate a =Profile= for the =User= instance if the User has just been created, instead of whenever the instance is updated.
*** admin.py
We need to register this new =Profile= model in =users/admins.py=, to have access to it in our admin app.

#+begin_src python
from django.contrib import admin
from .models import Profile

admin.site.register(Profile)
#+end_src
** Auth views
In =users/views.py=, we take advantage of the generic =LoginView=, =LogoutView=, and =CreateView= to implement our authentication logic:

#+begin_src python
from django.shortcuts import render
from django.contrib.auth.views import LoginView, LogoutView
from django.views.generic import CreateView
from django.urls import reverse_lazy
from .models import User


class Login(LoginView):
    template_name = "login.html"
    next_page = reverse_lazy("home")


class Logout(LogoutView):
    next_page = reverse_lazy("home")


class SignUpView(CreateView):
    model = User
    fields = ["username", "email", "password"]
    template_name = "signup.html"
    success_url = reverse_lazy("home")
#+end_src

We don't have to specify much to the generic views, they're quite full-featured as is. What we did here is indicate where the templates live and where the views redirect to (the [[https://docs.djangoproject.com/en/dev/ref/settings/#login-redirect-url][defaults]] are =accounts/profile= for =LoginView= and =None= for =LogoutView=).
We didn't specify a template for =LogoutView= because it's not necessary.
** Auth urls
Let's deal with the URL patterns now.
Create =users/urls.py= and add the following:

#+begin_src python
from django.urls import path
from .views import Login, Logout, SignUp


urlpatterns = [
    path("login", Login.as_view(), name="login"),
    path("logout", Logout.as_view(), name="logout"),
    path("signup", SignUp.as_view(), name="signup"),
]
#+end_src

For every app that we create, we need to tell =config/urls.py= to look at the patterns specified in the app's =urls.py= file:

#+begin_src python
urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("conduit.articles.urls")),
    path("", include("conduit.users.urls")),        # new
]
#+end_src
** Auth templates
*** login.html
Let's create =login.html= in the =templates= folder:

#+begin_src html
{% extends 'base.html' %}
{% block title %}
    <title>Sign in - Conduit: Django + HTMX</title>
{% endblock %}
{% block content %}
    <div class="auth-page">
        <div class="container page">
            <div class="row">
                <div class="col-md-6 offset-md-3 col-xs-12">
                    <h1 class="text-xs-center">Sign In</h1>
                    <p class="text-xs-center">
                        <a href="{% url 'signup' %}">Need an account?</a>
                    </p>
                    {{ form.non_field_errors }}
                    <form method="post">
                        {% csrf_token %}
                        <fieldset class="form-group">
                            <input
                                class="form-control form-control-lg"
                                type="email"
                                placeholder="Email"
                                name="{{ form.username.name }}"
                            >
                            {{ form.username.errors }}
                        </fieldset>
                        <fieldset class="form-group">
                            <input
                                class="form-control form-control-lg"
                                type="password"
                                placeholder="Password"
                                name="{{ form.password.name }}"
                            >
                            {{ form.password.errors }}
                        </fieldset>
                        <button class="btn btn-lg btn-primary pull-xs-right" type="submit">
                            Sign in
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src

Notice that we are using =form.username= to authenticate. I initially was trying to work with =form.email=, because that was the field we chose to authenticate with, but it kept throwing errors: Django didn't see the field, didn't POST the value that I gave it, and asked for the username every time. It took me a while, but I realised that our username /is/ the email. =form.username= is effectively querying what the =USERNAME_FIELD= is. Not straightforward though.
*** signup.html
Create =signup.html=:

#+begin_src html
{% extends 'base.html' %}
{% block title %}
    <title>Sign up - Conduit: Django + HTMX</title>
{% endblock %}
{% block content %}
    <div class="auth-page">
        <div class="container page">
            <div class="row">
                <div class="col-md-6 offset-md-3 col-xs-12">
                    <h1 class="text-xs-center">Sign up</h1>
                    <p class="text-xs-center">
                        <a href="{% url 'login' %}">Have an account?</a>
                    </p>
                    {{ form.non_field_errors }}
                    <form method="post">
                        {% csrf_token %}
                        <fieldset class="form-group">
                            <input
                                class="form-control form-control-lg"
                                type="text"
                                placeholder="Your {{ form.username.name }}"
                                name="{{ form.username.name }}"
                                value="{{ form.username.value|default_if_none:'' }}"
                            >
                        </fieldset>
                        {{ form.username.errors }}
                        <fieldset class="form-group">
                            <input
                                class="form-control form-control-lg"
                                type="email"
                                placeholder="Your {{ form.email.name }}"
                                name="{{ form.email.name }}"
                                value="{{ form.email.value|default_if_none:''  }}"
                            >
                        </fieldset>
                        {{ form.email.errors }}
                        <fieldset class="form-group">
                            <input
                                class="form-control form-control-lg"
                                type="password"
                                placeholder="Your {{ form.password.name }}"
                                name="{{ form.password.name }}"
                            >
                        </fieldset>
                        {{ form.password.errors }}
                        <button class="btn btn-lg btn-primary pull-xs-right">
                            Sign up
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src
** Nav
We don't want to expose the =New post= link to unauthenticated users.

In =nav.html=:

#+begin_src html
<nav class="navbar navbar-light">
    <div class="container">
        <a rel="prefetch" class="navbar-brand" href="/">conduit</a>
        <ul class="nav navbar-nav pull-xs-right">
            <li class="nav-item">
                <a rel="prefetch" class="nav-link" href="{% url 'home' %}">
                    Home
                </a>
            </li>
            {% if user.is_authenticated %}                          <!-- new from here -->
                <li class="nav-item">
                    <a rel="prefetch" href="{% url 'editor_create' %}" class="nav-link">
                        <span class="ion-compose"> New Post </span>
                    </a>
                </li>
                <li class="nav-item">
                    <a rel="prefetch" href="{% url 'logout' %}" class="nav-link">
                        <span class="ion-log-out"> Log out </span>
                    </a>
                </li>
            {% else %}
                <li class="nav-item">
                    <a rel="prefetch" href="{% url 'login' %}" class="nav-link">
                        Sign in
                    </a>
                </li>
                <li class="nav-item">
                    <a
                        rel="prefetch"
                        href="{% url 'signup' %}"
                        class="nav-link"
                    >
                        Sign up
                    </a>
                </li>
            {% endif %}                                             <!-- to here -->
        </ul>
    </div>
</nav>
#+end_src
** LoginRequiredMixin
Some pages should only be accessible to authenticated users, and Django provides an easy way of doing so through mixins. Mixins are components that provide common extra functionality. They can be added to class-based views on the fly.

In =articles/views.py=, add the following:

#+begin_src python
# other imports
from django.contrib.auth.mixins import LoginRequiredMixin

class EditorCreateView(LoginRequiredMixin, CreateView):
    # ...
class EditorDeleteView(LoginRequiredMixin, DeleteView):
    # ...
class CommentCreateView(LoginRequiredMixin, CreateView):
    # ...
class ArticleCommentView(LoginRequiredMixin, View):
    # ...
class CommentDeleteView(LoginRequiredMixin, DeleteView):
    # ...
#+end_src

Notice that the =LoginRequiredMixin= should be at the leftmost position in the inheritance list: don't write =class EditorDeleteView(DeleteView, LoginRequiredMixin)= if you want to avoid errors.

If you try creating a post from the app, you should get this error:

[[./Screenshots/login - error.png]]

The cause of the problem is given in the line:

#+begin_quote
The current path, accounts/login/, didn’t match any of these.
#+end_quote

By default, the login url in Django is =accounts/login/=: while we changed our urls everywhere, the =LoginRequiredMixin= does not know that. To fix this, we need to add this line in =config/settings.py=:

#+begin_src python
LOGIN_URL = "login"
#+end_src
** Testing signup and login
For now, we only have one user for our app: the =admin= superuser.

Let's create a new user by clicking on =Sign up= in our navbar. Enter a username, an email (which doesn't have to be a real one as long as it's the right format), and a password.

When you finalise this action by clicking the button =Sign up=, you'll notice that you're redirected to the homepage without being logged in. This is fine - you can sign in manually as the user you just created or you might want to implement an email verification before allowing sign ups - but, in our case, we might as well sign in the user automatically.

In =users/views.py=, add the following to =SignUpView= (as explained in [[https://stackoverflow.com/a/70582911][this StackOverflow answer]]):

#+begin_src python
# other imports
from django.shortcuts import render, redirect  # new
from django.contrib.auth import authenticate, login  # new

# other views
class SignUpView(CreateView):
    model = User
    fields = ["username", "email", "password"]
    template_name = "signup.html"
    success_url = reverse_lazy("home")

    def form_valid(self, form):  # new
        # create the User object
        user = form.save(commit=False)  # new
        # set password manually
        # as otherwise the User will be saved with unhashed password
        password = form.cleaned_data.get("password")  # new
        user.set_password(password)  # new
        # save the User object to the database
        user.save()  # new
        # authenticate your user with unhashed password
        # (`authenticate` expects unhashed passwords)
        email = form.cleaned_data.get("email")  # new
        authenticated_user = authenticate(email=email, password=password)  # new
        # log in
        login(self.request, authenticated_user)  # new
        return redirect(self.success_url)  # new
#+end_src

To make sure you understand what we're doing here: Django hashes passwords when creating a new =User=, but we need to make it explicit that the =password= field is the password (through =user.set_password(password)=) and needs to be hashed, otherwise there will be errors whenever we try to authenticate:
- Django will save the unhashed password to the database
- during login, it will take the user-submitted plaintext password and hash it
- check the hash of the user-submitted password against what it believes to be /the hash of the actual password/ in the database
- see that the two passwords don't match (obviously)
- refuse authentication.

Now that we've resolved the issue, try creating a new user: everything should work.
** Viewing profiles
It's time to allow users to view their profiles.

In =users/views.py=:

#+begin_src python
# other imports
from django.views.generic import CreateView, DetailView

# other views
class ProfileDetailView(DetailView):
    model = User
    template_name = "profile_detail.html"
#+end_src

In =users/urls.py=:

#+begin_src python
# other imports
from .views import Login, Logout, SignUpView, ProfileDetailView


urlpatterns = [
    # other paths
    path("profile/@<str:username>", ProfileDetailView.as_view(), name="profile_detail"),
]
#+end_src

In the =templates= folder, create =profile_detail.html=:

#+begin_src html
{% extends 'base.html' %}
{% block title %}
    <title>{{ profile.user.username }} - Conduit: Django + HTMX</title>
{% endblock %}
{% block content %}
    <div class="profile-page">
        <div class="user-info">
            <div class="container">
                <div class="row">
                    <div class="col-xs-12 col-md-10 offset-md-1">
                        <img src="{{ profile.image }}" class="user-img" alt="{{ profile.user.username }}" />
                        <h4>{{ profile.user.username }}</h4>
                        <p>{{ profile.bio|default:"This user doesn't have a bio for now" }}</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
#+end_src

Everything should be working now, right? Let's check by going to =localhost:8000/profile/@admin=, for example.
Welp, we're getting an error:
#+ATTR_ORG: :width 600
[[./Screenshots/profile_detail - error.png]]

The error tells us that our =ProfileDetailView= wants to be called with an object primary key or a slug, while we're calling it with a =username=. The solution is simple: we just change how the view decides which objects to show.

We override the view's =get_object= method by adding the following to =users/views.py=:

#+begin_src python
# other imports
from django.shortcuts import render, get_object_or_404

# other views
class ProfileDetailView(DetailView):
    model = Profile
    template_name = "profile_detail.html"

    def get_object(self, queryset=None):
        username = self.kwargs.get("username", None)
        user = get_object_or_404(User, username=username)
        return user.profile
#+end_src

Let's try again: we should see an actual profile page (though there isn't much on it yet). Make sure to set a profile image for your =admin= user, as everyone else should have a default already set.

#+ATTR_ORG: :width 600
[[./Screenshots/profile_detail.png]]
** Links to Profiles in templates
We now need to link the profile page from all the places our users' usernames are exposed.

In =templates/article_preview.html=, change the following lines:

#+begin_src html
<div class="article-meta">
  <a href="{% url 'profile_detail' username=article.author.user.username %}">                    <!-- new -->
    <img src="{{ article.author.image }}" alt="{{ article.author.user.username }}"/>           <!-- new -->
  </a>                                                                                           <!-- new -->
  <div class="info">
    <a href="{% url 'profile_detail' username=article.author.user.username %}" class="author"> <!-- from <span class="author"> -->
        {{ article.author.user.username }}
    </a>                                                                                       <!-- from </span> -->
    <span class="date">
      {{ article.created_at|date:"D M d Y" }}
    </span>
  </div>
</div>
#+end_src

In =templates/nav.html=:

#+begin_src html
{% if user.is_authenticated %}
  <li class="nav-item">
    <a rel="prefetch" href="{% url 'editor_create' %}" class="nav-link">
      <span class="ion-compose"> New Post </span>
    </a>
  </li>
  <li class="nav-item">                                                                          <!-- new -->
    <a rel="prefetch" href="{% url 'profile_detail' username=user.username %}" class="nav-link"> <!-- new -->
      <img src="{{ user.profile.image }}" class="user-pic" alt="{{ user.username }}">            <!-- new -->
      {{ user.username }}                                                                        <!-- new -->
    </a>                                                                                         <!-- new -->
  </li>                                                                                          <!-- new -->
  <li class="nav-item">
    <a rel="prefetch" href="{% url 'logout' %}" class="nav-link">
      <span class="ion-log-out"> Log out </span>
    </a>
  </li>
{% else %}
#+end_src

In =templates/article_detail.html=:

#+begin_src html
<div class="article-meta">
  <a href="{% url 'profile_detail' username=article.author.user.username %}">                  <!-- new -->
    <img src="{{ article.author.image }}" alt="{{ article.author.user.username }}"/>           <!-- new -->
  </a>                                                                                         <!-- new -->
  <div class="info">
    <a href="{% url 'profile_detail' username=article.author.user.username %}" class="author"> <!-- from <span class="author"> -->
      {{ article.author.user.username }}
    </a>                                                                                       <!-- from </span> -->
    <span class="date">
      {{ article.created_at|date:"D M d Y" }}
    </span>
  </div>
#+end_src

In =templates/comments.html=:

#+begin_src html
<div class="card-footer">
  <a href="{% url 'profile_detail' username=comment.author.user.username %}" class="comment-author">            <!-- new -->
    <img src="{{ comment.author.image }}" class="comment-author-img" alt="{{ comment.author.user.username }}"/> <!-- new -->
  </a>                                                                                                          <!-- new -->
  <a href="{% url 'profile_detail' username=comment.author.user.username %}" class="comment-author"> <!-- from <span class="comment-author"> -->
      {{ comment.author.user.username }}
  </a>                                                                                               <!-- from </span>-->
  <span class="date-posted">
    {{ comment.created_at|date:"D M d Y" }}
  </span>
  {% include 'comment_delete.html' %}
</div>
#+end_src
*** TODO replace {% url 'profile_detail' username=... %} with {{ ...profile.get_absolute_url }}
** Editing profiles
We want to allow users to modify their profile information (username, email, password, image, bio). This is straightforward: we have done it a few times by now.

In =users/views.py=:

#+begin_src python
# other imports
from django.views.generic import CreateView, DetailView, UpdateView
from django.contrib.auth.mixins import LoginRequiredMixin

# other classes
class ProfileUpdateView(LoginRequiredMixin, UpdateView):
    model = Profile
    fields = ["image", "user.username", "bio", "user.email", "user.password"]
    template_name = "settings.html"

    def get_object(self, queryset=None):
        return self.request.user.profile
        # return Profile.objects.get(user=self.request.user)
#+end_src

Our =ProfileUpdateView= only allows to update the =Profile= associated with the current =User=: users should only be able to edit their own profile.

In =users/urls.py=:

#+begin_src python
# other imports
from .views import Login, Logout, SignUpView, ProfileDetailView, ProfileUpdateView


urlpatterns = [
    # other paths
    path("settings/", ProfileUpdateView.as_view(), name="settings"),
]
#+end_src

In =templates/nav.html=:

#+begin_src html
<li class="nav-item">
  <a rel="prefetch" href="{% url 'editor_create' %}" class="nav-link">
    <span class="ion-compose"> New Post </span>
  </a>
</li>
<li class="nav-item">                                              <!-- new -->
  <a rel="prefetch" href="{% url 'settings' %}" class="nav-link">  <!-- new -->
    <span class="ion-gear-a"> Settings </span>                     <!-- new -->
  </a>                                                             <!-- new -->
</li>                                                              <!-- new -->
<li class="nav-item">
  <a rel="prefetch" href="{% url 'profile_detail' username=user.username %}" class="nav-link">
    <img src="{{ user.profile.image }}" class="user-pic" alt="{{ user.username }}">
    {{ user.username }}
  </a>
</li>
#+end_src

In =templates/settings.html=:

#+begin_src html
#+end_src
* Follows, favorites, and tags
* UI stuff
** TODO class:active
*** [[https://stackoverflow.com/questions/340888/navigation-in-django/341748#341748][Navigation in django - Stack Overflow]]
*** [[https://stackoverflow.com/questions/340888/navigation-in-django/477719#477719][Navigation in django - Stack Overflow]]
* Observations
- =Nav=
- home.html
  + =banner= if user is not authenticated
  + =tabs= ('Global feed', 'Your feed', tag if the user's looking at a tag feed)
  + =ArticleList= w
    * =ArticlePreview=
  + =Pagination=
  + =Popular tags=
- article.html
  + banner
    * article.title
    * ArticleMeta
  + article.body
  + article.tagList
  + CommentContainer
    * CommentInput
    * Comment
