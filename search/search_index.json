{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Readme","text":"<p>Warning</p> <p>I'm rewriting this tutorial in depth, to improve the structure, the explanations, the code, and implement the \"Coming soon\" sections.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>In this tutorial, we'll be building the Thinkster's RealWorld Example App from the ground up.</p> <p>The app is called Conduit and is a Medium clone: you can see it running at https://demo.realworld.io.</p> The RealWorld app, in all its glory <p>The common way to approach this would be to build the backend in Django, do the frontend with a JavaScript framework (React, Vue, Svelte, etc.) and glue everything together with an API (Flask, Django REST Framework, etc.).</p> <p>Thanks to frameworks like HTMX and AlpineJS, the common way described above is getting closer and closer towards becoming an exercise in overengineering. We can built our whole app in Django, both the backend and the frontend, with some help from HTMX and AlpineJS, so we'll do just that, and along the way we'll show that server-side rendering is going strong.</p>"},{"location":"#what-to-expect-from-this-tutorial","title":"What to expect from this tutorial","text":"<p>This tutorial documents my own path to learning Django. I hope it will contribute to closing the gap in the learning materials available to \u201cmedium to advanced beginners\u201d: those who have built every fake blog in existence, but who don't don't benefit from more in-depth resources because they don't have a real codebase to work on.</p> <p>We are aiming to build a tutorial that will teach the user to debug Django, to read the docs, to implement features that are not built-in.</p> <p>We will be bumping into errors, reading error messages, and sometimes even using actual debuggers to fix our app. We'll be jumping in and out of the shell to see how the internals function. Whenever we need to implement a feature, we'll take the path that teaches us Django (but also show the alternative that simply solves the specific problem).</p> <p>Hopefully this will provide you (and us) with a good grasp of Django.</p>"},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Tools</li> <li>Python 3.9</li> <li>Django 5.0 (the tutorial should work fine in Django 3.2 however)</li> <li>HTMX</li> <li>AlpineJS</li> <li>Strongly recommended<ul> <li>conda or virtualenv for making virtual environments</li> <li>git, to keep track of your work We assume that you know the basics of git. You should <code>git commit</code> at the end of every chapter.</li> <li>ipython, to have an interactive shell</li> </ul> </li> <li>Optional<ul> <li>faker, to avoid creating placeholder users, articles and comments, manually</li> <li>django-debug-toolbar and pudb to help debug our web app</li> </ul> </li> <li>Knowledge</li> <li>DjangoGirls tutorial You should have followed the DjangoGirls tutorial before starting this one: it is great for getting you up to speed, and covers most of the introductory material you'll need, like HTML, CSS, and, of course, Django. We'll assume you have completed that tutorial and won't go into the specifics of anything that has already been covered there.</li> </ul>"},{"location":"#what-well-be-doing","title":"What we'll be doing","text":"<ol> <li>First, we'll decide on a project and folder structure, to keep the project's complexity in check. We'll also do the groundwork required by Django before we can get our app running online.</li> <li>We'll then dive into the tutorial proper: we'll make our first models, views, templates. We'll also create some articles through the Django admin app to have something nice to look at.</li> <li>Next, we'll spend some time on implementing features for viewing, creating, editing, and deleting articles.</li> <li>We'll then implement the same things for comments.</li> <li>After that, we'll spend a while on authentication and profile features (which includes follows, favorites, and tags). At this point, our app will be as finished as can be with Django alone.</li> <li>Finally, we'll implement HTMX and AlpineJS to make our app indistinguishable from a traditional SPA.</li> </ol>"},{"location":"#why-no-rest","title":"Why no REST?","text":"<p>Because our entire frontend is integrated into Django (through HTML templates and HTMX), and given the scope of tutorial, we can implement the whole app without building a REST API. So we won't. This has a few benefits:</p> <ul> <li>we keep the structure of the app simple</li> <li>we keep the mental load light: no need to understand how Django REST Framework (the preferred way of implementing REST APIs in Django) works, no need to juggle with serializers, routers, renderers, etc., no need to complicate the codebase</li> <li>because we don't use a REST API, we don't need to implement JWT authentication, which is a general pain: we can just rely on Django's built-in authentication solutions, which are robust and simple to implement.</li> </ul> <p>The cons of this decision are that we won't be able to learn what there is to learn about building REST APIs with Django, which is a major use case for the framework: maybe a future version of this tutorial will include a chapter on this (but for now we want to let HTMX and AlpineJS shine).</p>"},{"location":"#thanks","title":"Thanks","text":"<p>Thanks to the Django project. Does this even need to be said? But seriously, thank you Django for existing.</p> <p>Thanks to HTMX and AlpineJS for the SSR revolution.</p> <p>Thanks to the Realworld team for having been the catalyst for so many projects.</p> <p>Thanks to the Svelte community: throughout this tutorial, for anything that has to do with templates, we're simply adapting the templates from the Svelte implementation of the Realworld app's frontend. Svelte and the Django templating language are so similar that \u201cadapting\u201d the code mostly meant copying it.</p> <p>Thanks to the Django docs, universally praised as some of the best documentation in existence.</p> <p>Thanks to the excellent Two Scoops of Django by Daniel and Audrey Feldroy: highly recommended if you want to be exposed to best practice in Django.</p>"},{"location":"01_starting_the_project/","title":"Starting the project","text":""},{"location":"01_starting_the_project/#introduction","title":"Introduction","text":"<p>Let's start this tutorial in earnest.</p> <p>In this chapter:</p> <ul> <li>we'll set up everything we'll need to start coding (our virtual environment and our project directories)</li> <li>we'll learn how to structure a Django project, how to create applications, how to change settings</li> <li>we'll write several models, create a database, use the famed Django admin, and finally get our app running locally.</li> </ul>"},{"location":"01_starting_the_project/#virtual-environment","title":"Virtual environment","text":"<p>Before doing anything else, we need to create our virtual environment.</p> <p>We're working with <code>conda</code> (tutorial), but you can use your favourite virtual lib, like <code>virtualenv</code> (tutorial).</p> <pre><code>~$ conda create --name django\n(django) ~$ conda activate django\n(django) ~$ conda install django faker\n</code></pre> <p>Now, you have a virtual environment with <code>django</code> and <code>faker</code> installed.</p>"},{"location":"01_starting_the_project/#project-layout-and-folder-structure","title":"Project layout and folder structure","text":"<p>We'll be following a simplified version of the folder structure described in the Two Scoops of Django by Daniel and Audrey Feldroy.</p> <p>We want our folder structure to look something like the following:</p> <pre><code>folder_name\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 settings/\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 project_name/\n\u2502   \u251c\u2500\u2500 app_1/\n\u2502   \u251c\u2500\u2500 app_2/\n\u2502   \u251c\u2500\u2500 static/\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 db.sqlite3\n</code></pre> <p>Before we get there, however, we need to go through the Django defaults.</p> <p>Let's create a folder for our project: we'll name it <code>django_tutorial</code>. After that, we'll create our project, <code>conduit</code>, inside <code>django_tutorial</code>:</p> <pre><code>(django) ~$ mkdir django_tutorial\n(django) ~$ cd django_tutorial\n(django) django_tutorial$ django-admin startproject conduit .\n</code></pre> <p>Advice</p> <p>We strongly recommend you use git when going through this tutorial.</p> <p>Our folder structure should look like this at this point:</p> <pre><code>django_tutorial\n\u251c\u2500\u2500 conduit\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>We'll move all the files in the <code>conduit</code> folder into the <code>django_tutorial/config</code> folder, as we explained above. The project layout should now be:</p> <pre><code>django_tutorial\n\u251c\u2500\u2500 conduit\n\u2502\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>Because we're deviating from Django's generic project layout, we'll have to update some lines in the settings. You might wonder why we have to fiddle with the settings before even starting to code, but this small effort has the benefit of making the structure of our project easier to understand, and of separating the config from the code, which is a good habit to get into.</p> <p>In <code>config/asgi.py</code>, <code>config/wsgi.py</code>, and <code>./manage.py</code>, we update the location of our <code>settings.py</code> file:</p> <pre><code># ...\n\n# os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"conduit.settings\")       # from this\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings\")          # to this\n</code></pre> <p>We do the same in <code>config/settings.py</code>:</p> <pre><code># ...\n\n# ROOT_URLCONF = \"conduit.urls\"         # from this\nROOT_URLCONF = \"config.urls\"            # to this\n\n# WSGI_APPLICATION = \"conduit.wsgi.application\"     # from this\nWSGI_APPLICATION = \"config.wsgi.application\"        # to this\n</code></pre> <p>Done! We have implemented a project layout that separates the config (in the <code>config</code> folder) from the code (in the <code>conduit</code> folder) and told Django to take this into account.</p> <p>Our app will have a lot of moving parts (articles, profiles, tags, etc.). To keep the structure of our app clear, we'll host the logic for each of these parts in separate folders.</p> <p>We'll build Conduit step by step.</p>"},{"location":"01_starting_the_project/#articles-application","title":"<code>articles</code> application","text":"<p>The most basic function that the Conduit app should have is the ability to post and read articles. Let's start with that (you'll notice that this part is basically a repeat of DjangoGirls tutorial's blog app).</p> <p>We'll create an <code>articles</code> application (a package that provides a specific set of features) that will hold all the logic that is related to dealing with articles.</p> <pre><code>(django) django_tutorial$ cd conduit\n(django) conduit$ django-admin startapp articles\n(django) conduit$ cd articles\n</code></pre> <p>Our folder structure now looks like this:</p> <pre><code>django_tutorial\n\u251c\u2500\u2500 conduit\n\u2502   \u251c\u2500\u2500 articles\n\u2502   \u2502   \u251c\u2500\u2500 admin.py\n\u2502   \u2502   \u251c\u2500\u2500 apps.py\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 migrations\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 tests.py\n\u2502   \u2502   \u2514\u2500\u2500 views.py\n\u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>Because of our folder structure, we will need to make a small adjustment in the file <code>articles/apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\n\nclass ArticlesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    # name = \"articles\"             # from this\n    name = \"conduit.articles\"       # to this\n</code></pre> <p>We also add the <code>articles</code> application to the <code>INSTALLED_APPS</code> setting in <code>config/settings.py</code>, in order to let Django know about our new app <code>articles</code>:</p> <pre><code>INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"conduit.articles\",             # new\n]\n</code></pre>"},{"location":"01_starting_the_project/#users-app-and-user-model","title":"<code>users</code> app and <code>User</code> model","text":"<p>The Django docs warn you: \u201cIf you're starting a new project, it's highly recommended to set up a custom user model, even if the default User model is sufficient for you. [\u2026] Changing AUTH_USER_MODEL after you've created database tables is significantly more difficult [\u2026]. This change can't be done automatically and requires manually fixing your schema, moving your data from the old user table, and possibly manually reapplying some migrations.\u201d.</p> <p>Scary stuff. Let's just follow the advice.</p> <p>First, we need to create the app where we'll put all the logic that has to do with users.</p> <pre><code>(django) conduit$ django-admin startapp users\n</code></pre> <p>We remember to take into account our folder structure in <code>users/apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\n\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    # name = \"users\"            # from this\n    name = \"conduit.users\"      # to this\n</code></pre> <p>And we add the new <code>users</code> application to our <code>INSTALLED_APPS</code> in <code>config/settings.py</code>:</p> <pre><code># ...\nINSTALLED_APPS = [\n    # ...\n    \"conduit.users\",            # new\n]\n</code></pre> <p>Now, in <code>users/models.py</code>, add the following:</p> <pre><code>from django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\n\nclass User(AbstractUser):\n    \"\"\"Custom user model.\"\"\"\n\n    pass\n</code></pre> <p>What we're doing here is exactly what the Django docs advise us to do: we take the <code>AbstractUser</code> model and save it as is, which will provide us with a custom user model. This way, we can add any modifications that we need later on.</p> <p>Finally, we need to tell Django that we're not using the default <code>User</code> model. In <code>config/settings.py</code>, point <code>AUTH_USER_MODEL</code> to it:</p> <pre><code># ...\nAUTH_USER_MODEL = \"users.User\"      # new\n</code></pre> <p>Great, our <code>user</code> application and our custom <code>User</code> model are ready.</p>"},{"location":"01_starting_the_project/#create-a-database","title":"Create a database","text":"<p>Django uses a SQLite database by default: it's versatile, simple, and sufficient for our needs. Django also supports other databases, notably PostgreSQL, which is what we would want to use if our app was expected to grow fast, but for now we will stay with SQLite.</p> <p>Info</p> <p>We would arguably learn more by setting up a PosgreSQL database: SQLite is a \u201cset it and forget it\u201d, \u201cjust works\u201d type of thing. Since learning more is the point of this tutorial, we might shift to PostgreSQL at some point.</p> <p>After any change to a model, we need to sync the database so that the changes can be propagated into the database schema. If you don't yet know what that means, no worries: we'll have a much closer look at what exactly is in our database, and what happens when we run migrations.</p> <p>Specifically in this case, we want Django to create an <code>Article</code> table that will hold our articles.</p> <p>Since we changed the <code>Articles</code> model, we will run the following commands:</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# Operations to perform:\n#   Apply all migrations: admin, auth, contenttypes, sessions, users\n(django) django_tutorial$ python manage.py migrate\n# Operations to perform:\n#   Apply all migrations: admin, auth, contenttypes, sessions, users\n# Running migrations:\n#   Applying contenttypes.0001_initial... OK\n#   Applying contenttypes.0002_remove_content_type_name... OK\n#   Applying auth.0001_initial... OK\n#   Applying auth.0002_alter_permission_name_max_length... OK\n#   Applying auth.0003_alter_user_email_max_length... OK\n#   Applying auth.0004_alter_user_username_opts... OK\n#   Applying auth.0005_alter_user_last_login_null... OK\n#   Applying auth.0006_require_contenttypes_0002... OK\n#   Applying auth.0007_alter_validators_add_error_messages... OK\n#   Applying auth.0008_alter_user_username_max_length... OK\n#   Applying auth.0009_alter_user_last_name_max_length... OK\n#   Applying auth.0010_alter_group_name_max_length... OK\n#   Applying auth.0011_update_proxy_permissions... OK\n#   Applying auth.0012_alter_user_first_name_max_length... OK\n#   Applying users.0001_initial... OK\n#   Applying admin.0001_initial... OK\n#   Applying admin.0002_logentry_remove_auto_add... OK\n#   Applying admin.0003_logentry_add_action_flag_choices... OK\n#   Applying sessions.0001_initial... OK\n</code></pre> <p>We'll be doing this many times throughout the tutorial: if your app refuses to run at some point, the most likely error (from experience) is that you forgot to migrate, so make sure you keep on top of it.</p>"},{"location":"01_starting_the_project/#create-a-superuser","title":"Create a superuser","text":"<p>One of Django's greatest advantages is its admin app: it is considered so helpful that you probably will see it mentioned in most discussions about Django.</p> <p>To be able to access the admin app (which we will do in a later section), we need a superuser. Run the following and fill the values (you don't need a real email or a strong password here):</p> <pre><code>(django) django_tutorial$ python manage.py createsuperuser\n# Username (leave blank to use $CURRENTUSER): admin\n# Email address: admin@example.com\n# Password:\n# Password (again):\n# Superuser created successfully.\n</code></pre>"},{"location":"01_starting_the_project/#profile-model","title":"<code>Profile</code> model","text":"<p>In <code>users/models.py</code> we also need to create a <code>Profile</code> model: we'll explain it in more detail later, but suffice it to say that the <code>Profile</code> will deal with everything about our users that is not authentication (ie logging in and out).</p> <pre><code># ...\n\nclass Profile(models.Model):\n    \"\"\"Profile model associated to each User object.\"\"\"\n\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.user.username\n</code></pre> <p>We'll go through the code step by step:</p> <ul> <li>The docs for the <code>OneToOneField</code> model field read: \u201cA one-to-one relationship. Conceptually, this is similar to a ForeignKey with unique=True, but the \u201creverse\u201d side of the relation will directly return a single object. This is most useful as the primary key of a model which \u201cextends\u201d another model in some way\u201d. This is exactly we need, because each <code>User</code> has one associated <code>Profile</code>, and each <code>Profile</code> corresponds to a single <code>User</code>.</li> <li><code>on_delete</code> is a required argument for <code>OneToOneField</code> and specifies what happens when the model instance is deleted.</li> <li>the <code>__str__</code> method tells Django what the string representation of the model should be: this is how specific model instances will be represented in the Django admin app, in the shell, in the error messages, in the templates, etc. Here, we specify that we want our profiles to be referenced by the associated user's username.</li> </ul> <p>Now that we have a <code>Profile</code> model, we want to create one for our existing user (the <code>admin</code> superuser). Later on, we will automate the creation of a profile for every new user, but this is not implemented yet, so we need to do it manually. Well, thankfully Django allows us to interact with it through a Python shell.</p> <pre><code>(django) django_tutorial$ python manage.py shell\n</code></pre> <p>And now that we're in the IPython shell, we will interact with the Django ORM: we will get our <code>admin</code> user from the <code>User</code> objects and then create a <code>Profile</code> instance.</p> <pre><code>In [1]: from django.contrib.auth import get_user_model\n\nIn [2]: from conduit.users.models import Profile\n\nIn [3]: user = get_user_model().objects.get(username='admin')\n\nIn [4]: user.profile = Profile.objects.create(user=user)\n</code></pre> <p>You might wonder why we're importing <code>get_user_model</code> instead of the <code>User</code> model directly: this is best practice and ensures we're working with the currently active user model.</p> <p>However, if you've been following up to now\u2026 you should have gotten an error above. Namely, you should have gotten:</p> <p>OperationalError: no such table: users_profile</p> <p>90% of programming is writing code, and the other 90% of programming is debugging, as the saying goes, so we might as well learn to deal with Django's errors while learning Django. The error above says that our database has no table <code>users_profile</code>: why might that be? Because we didn't sync our database after modifying our models!</p> <p>Open a new terminal session and run migrations:</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# Migrations for 'users':\n#   conduit/users/migrations/0002_profile.py\n#     - Create model Profile\n(django) django_tutorial$ python manage.py migrate\n# Operations to perform:\n#   Apply all migrations: admin, auth, contenttypes, sessions, users\n# Running migrations:\n#   Applying users.0002_profile... OK\n</code></pre> <p>Now return to the previous session and rerun the shell command: there should be no error this time.</p>"},{"location":"01_starting_the_project/#start-the-server","title":"Start the server","text":"<p>We have everything we need to actually run our app. Let's start the server!</p> <pre><code>(django) django_tutorial$ python manage.py runserver\n</code></pre> <p>You should see this:</p> python manage.py runserver <p>Our app, Conduit, is online!</p>"},{"location":"01_starting_the_project/#article-model","title":"<code>Article</code> model","text":"<p>We'll start by making a model for our articles.</p> <p>When creating a model, we need to think of what fields the model will need. Let's take 2 seconds to think. Any article needs:</p> <ul> <li>a title</li> <li>a body (the text)</li> <li>a description</li> <li>an author</li> <li>a creation date.</li> </ul> <p>Let's implement that in <code>articles/models.py</code>.</p> <pre><code>from django.db import models\n\n\nclass Article(models.Model):\n    \"\"\"Article model.\"\"\"\n\n    title = models.CharField(db_index=True, max_length=255)\n    description = models.TextField(max_length=2000)\n    body = models.TextField()\n    author = models.ForeignKey(\n        \"users.Profile\",\n        on_delete=models.CASCADE,\n        related_name=\"articles\",\n    )\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Let's explain everything step by step:</p> <ul> <li>the article's <code>title</code> will be used as <code>db_index</code>: when we do queries on articles in our database, we'll often be looking at the <code>title</code>, so having this field as index will speed the queries</li> <li><code>description</code> and <code>body</code> are self-explanatory</li> <li><code>author</code> is a bit more complicated:</li> <li>the <code>ForeignKey</code> model field allows us to have a many-to-one relationship: multiple articles for every profile</li> <li>we have seen <code>on_delete</code>, but not <code>related_name</code>: <code>related_name=\"articles\"</code> allows us to access a user's (or rather profile's) articles through an <code>articles</code> attribute (for example, <code>User.articles.all()</code> to get the <code>admin</code> user's articles)</li> <li><code>auto_now_add</code> simply records the time of creation for <code>created_at</code></li> <li>the <code>__str__</code> method says that the string representation of an article will be its title</li> </ul> <p>Let's sync the database again:</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# Migrations for 'articles':\n#   conduit/articles/migrations/0001_initial.py\n#     - Create model Article\n(django) django_tutorial$ python manage.py migrate\n# Operations to perform:\n#   Apply all migrations: admin, articles, auth, contenttypes, sessions, users\n# Running migrations:\n#   Applying articles.0001_initial... OK\n</code></pre>"},{"location":"01_starting_the_project/#using-the-django-admin","title":"Using the Django admin","text":"<p>In order to have something to work with for the rest of the tutorial, we need to create some posts. Because we can't yet do it through Conduit, we will do so through Django admin.</p> <p>In order for the Django admin to have access to the <code>Article</code> model, we need to register it in <code>articles/admin.py</code>:</p> <pre><code>from django.contrib import admin\nfrom .models import Article             # new\n\nadmin.site.register(Article)            # new\n</code></pre> <p>That's it, the <code>Article</code> model is now editable through the Django admin. The server should still be running (otherwise restart it). We will go to the Django admin app (http://127.0.0.1:8000/admin/) and log in as the superuser (<code>admin</code> in my case) that we created earlier.</p> <p>Once we're logged in, we will create three articles in Django admin:</p> <ol> <li>click \u201c:heavy-plus-sign: Add\u201d in the <code>Articles</code> section</li> <li>specify a title, a description, a body, and the author (you) for the article</li> <li>click \u201cSave and add another\u201d</li> </ol>"},{"location":"02_home_page/","title":"Home page","text":""},{"location":"02_home_page/#introduction","title":"Introduction","text":"<p>In this chapter, we'll bring an MVP of our app online: it'll have a landing page, some articles, and even a navbar! To achieve this, we will need to write our first view, templates, and URLs.</p>"},{"location":"02_home_page/#home-view","title":"Home view","text":"<p>Up to now, http://127.0.0.1:8000/ still shows the rocket celebrating a successful install, but what we want is to see our own app.</p> <p>In Conduit, the default view that the unauthenticated user sees on the home page is the \u201cglobal feed\u201d, or the list of all articles. That's what we need to implement.</p> <p>In <code>articles/views.py</code>, we add the following:</p> <pre><code>from django.views.generic import ListView\n\nfrom .models import Article\n\n\nclass Home(ListView):\n    \"\"\"View all published articles for the global feed.\"\"\"\n\n    queryset = Article.objects.order_by(\"-created_at\")\n    context_object_name = \"articles\"\n</code></pre> <p>Step by step:</p> <ul> <li>The <code>ListView</code> generic display view displays list of objects: the Django Girls tutorial only presents Function-Based Views, which are arguably a more intuitive option, but Class-Based Views (or CBVs) are considered to be best practice, at least according to Two Scoops of Django, and simplify a lot of work</li> <li>the <code>queryset</code> attribute (which is shorthand for the <code>get_queryset</code> method) allows us to filter the list of objects returned by <code>ListView</code> the way we need (here, we order them from most to least recent), while the default would be to simply specify <code>model = Article</code> and get <code>Article.objects.all()</code></li> <li>the <code>context_object_name</code> attribute provides a human-friendly name for the context for us to use in the template (by default, the context would be stored in a variable named <code>object_list</code>).</li> </ul>"},{"location":"02_home_page/#home-url","title":"Home URL","text":"<p>If you followed any previous tutorial, you will remember that, in order to display a view, we need to specify what URL it corresponds to.</p> <p>To keep our app logic clear, we will be keeping everything segregated across our apps: since we want to implement a view of the list of all articles, we will specify the URLs in our <code>articles</code> folder.</p> <p>Let's create a <code>articles/urls.py</code>, and add the following:</p> <pre><code>from django.urls import path\n\nfrom .views import Home\n\nurlpatterns = [\n    path(\"\", Home.as_view(), name=\"home\"),\n]\n</code></pre> <p>We're telling our <code>Articles</code> app that the root URL (http://127.0.0.1:8000/) should return the view <code>Home</code> that we created in the previous section. The <code>as_view()</code> method for class-based views returns a callable instance of the view, same as if we were calling a function-based view.</p> <p>However, Django doesn't know to look into <code>articles/urls.py</code>: it is only aware of the default <code>urls.py</code> file created earlier in the previous chapter. We add the following line in <code>config/urls.py</code>, so that the project-level <code>urls.py</code> is aware of the app-level URLs defined in <code>articles/urls.py</code>:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path, include                       # new\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"\", include(\"conduit.articles.urls\")),             # new\n]\n</code></pre>"},{"location":"02_home_page/#templates-and-static-files","title":"Templates and static files","text":"<p>We have a Home view and URL: we need a template now. In keeping with our commitment to keeping the structure of our project clear and logical, we will create a single project-wide folder for all templates, and we'll do the same for static files (icons, CSS, etc.): this kind of code is going to be heavily shared by both <code>articles</code> and <code>users</code> apps, so it's better to have a folder for the whole project than one for each app (all the more so that our apps are not expected to be plugged into other projects).</p> <p>Let's create the <code>templates</code> and <code>static</code> folders:</p> <pre><code>(django) conduit$ mkdir templates\n(django) conduit$ mkdir static\n</code></pre> <p>We need to modify <code>config/settings.py</code> so Django is aware of our project's architecture.</p> <p>Let's define the <code>APPS_DIR</code> below <code>BASE_DIR</code> first: it will point to our <code>conduit</code> folder and will make the next modifications a bit shorter.</p> <pre><code># ...\nBASE_DIR = Path(__file__).resolve().parent.parent\nAPPS_DIR = BASE_DIR / \"conduit\"                     # new\n</code></pre> <p>The <code>TEMPLATES</code> section of <code>config/settings.py</code> holds the template-related settings: that's where we need to notify Django about where our templates are.</p> <p>The <code>DIRS</code> setting, which indicates the location of template source files should point to our new <code>conduit/templates</code> folder:</p> <pre><code>TEMPLATES = [\n    {\n        # ...\n        # \"DIRS\": [],                       # from this\n        \"DIRS\": [APPS_DIR / \"templates\"],   # to this\n    },\n]\n</code></pre> <p>We will also change the <code>STATICFILES_DIRS</code> setting in the static files section of <code>config/settings.py</code> so that it points to our new <code>conduit/static</code> folder:</p> <pre><code># ...\nSTATIC_URL = \"/static/\"\nSTATICFILES_DIRS = [APPS_DIR / \"static\"]    # new\n</code></pre>"},{"location":"02_home_page/#base-template","title":"Base template","text":"<p>Before we start writing the templates, a few words. As stated in the introduction, the HTML is adapted from other RealWorld projects: mostly the Svelte implementation (because Svelte is unexpectedly close to Django's templating language), but we also picked and chose from other projects, both in situations where the code or the file structure were more in line with what we needed here, or when the UI of one implementation was better in some way. However, because we're building the app from scratch (adding features, changing the UI, etc.), our file structure and code will be affected. The HTML of the finished Conduit app should be almost identical to any other implementation's HTML (take or leave some specificities of our chosen frameworks). Because this is not an HTML or UI tutorial, we won't be explaining the HTML files' structure, the classes, the CSS, etc. Onwards!</p> <p>The groundwork is completed: Django knows where to find our templates. Let's create the base template then.</p> <pre><code>(django) conduit$ touch templates/base.html\n</code></pre> <p>The <code>templates/base.html</code> template, copied from Svelte's app.html file, will contain the following:</p> <pre><code>&lt;!DOCTYPE html&gt;\n{% load static %}\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;link rel=\"icon\" href=\"{% static '/icons/favicon.ico' %}\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;!-- icons for later --&gt;\n    &lt;link href=\"//code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n    &lt;!-- fonts --&gt;\n    &lt;link href=\"//fonts.googleapis.com/css?family=Titillium+Web:700|Source+Serif+Pro:400,700|Merriweather+Sans:400,700|Source+Sans+Pro:400,300,600,700,300italic,400italic,600italic,700italic\" rel=\"stylesheet\" type=\"text/css\"&gt;\n    &lt;!-- Thinkster's CSS --&gt;\n    &lt;link rel=\"stylesheet\" href=\"//demo.productionready.io/main.css\"&gt;\n    {% block title %}\n      &lt;title&gt;Conduit: Django + HTMX&lt;/title&gt;\n    {% endblock %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;main&gt;\n      {% block content %}\n      {% endblock %}\n    &lt;/main&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Step by step:</p> <ul> <li>the <code>{% load static %}</code> tag allows to make available the static files located in the <code>static</code> folder</li> <li><code>{% block title %}</code> and <code>{% block content %}</code> are <code>block</code> tags and define the parts of the template that will be overridden by child templates through Django's template inheritance, which will be illustrated in the very next section</li> </ul> <p>We also need to download the favicon referenced in our template: download the file located at the URL below to <code>static/icons/favicon.ico</code>:</p> <p>https://github.com/gothinkster/react-redux-realworld-example-app/blob/master/public/favicon.ico</p>"},{"location":"02_home_page/#home-template","title":"Home template","text":"<p>Time to make the <code>home.html</code> template: for now it only needs to display our \u201cglobal feed\u201d.</p> <p>Let's create the <code>templates/home.html</code> template (based on Svelte's index.svelte and ArticleList templates) and add the following to it:</p> <pre><code>{% extends 'base.html' %}\n{% block content %}\n  &lt;div class=\"home-page\"&gt;\n    &lt;div class=\"banner\"&gt;\n      &lt;div class=\"container\"&gt;\n        &lt;h1 class=\"logo-font\"&gt;conduit&lt;/h1&gt;\n        &lt;p&gt;A place to share your knowledge.&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"container page\"&gt;\n      &lt;div class=\"row\"&gt;\n        &lt;div class=\"col-md-9\"&gt;\n          {% if articles|length_is:\"0\" %}\n            &lt;div class=\"article-preview\"&gt;\n              No articles are here... yet.\n            &lt;/div&gt;\n          {% else %}\n            &lt;div&gt;\n              {% for article in articles %}\n                &lt;div class=\"article-preview\"&gt;\n                  &lt;div class=\"article-meta\"&gt;\n                    &lt;div class=\"info\"&gt;\n                      &lt;span class=\"author\"&gt;\n                        {{ article.author.user.username }}\n                      &lt;/span&gt;\n                      &lt;span class=\"date\"&gt;\n                        {{ article.created_at|date:\"D M d Y\" }}\n                      &lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                  &lt;a href=\"\" class=\"preview-link\"&gt;\n                    &lt;h1&gt;{{ article.title }}&lt;/h1&gt;\n                    &lt;p&gt;{{ article.description }}&lt;/p&gt;\n                    &lt;span&gt;Read more...&lt;/span&gt;\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              {% endfor %}\n            &lt;/div&gt;\n          {% endif %}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>A quick explanation:</p> <ul> <li>we show the classic Conduit banner</li> <li>with an <code>if</code> template tag and the <code>length_is</code> template filter we check that our <code>articles</code> variable (which we have named with <code>context_object_name = \"articles\"</code> in the <code>Home</code> view, remember?) has at least 1 article:</li> <li>if there are no articles, we show a message</li> <li>otherwise, we iterate through the articles with a <code>for</code> template tag (the syntax is the same as for a normal Python <code>for</code> loop) and show a preview:<ul> <li>the preview contains the article's author's username, creation date, title, and description</li> <li>the preview redirects to nothing for now (even though we don't have any links to show yet, we need to have a link there for CSS reasons)</li> </ul> </li> </ul> <p>Let's go to our server and reload the page: surely we can finally contemplate our glorious creation? No. If you've been following, you should see the error below:</p> <p>TemplateDoesNotExist at /</p> <p>articles/article_list.html</p> <p>Request Method: GET Request URL: http://127.0.0.1:8000/ Django Version: 4.0.4 Exception Type: TemplateDoesNotExist Exception Value:</p> <p>articles/article_list.html</p> <p>What the error says is that the template is missing, even though we know that it definitely is there. The issue is that Django expects a template named article_list.html, which is the default template expected by our <code>Home</code> view, which is a <code>ListView</code> for the <code>Article</code> model. To fix that, we need to go to <code>articles/views.py</code> and add the following:</p> <pre><code>class Home(ListView):\n    \"\"\"View all published articles for the global feed.\"\"\"\n\n    template_name = \"home.html\"                         # new\n    queryset = Article.objects.order_by(\"-created_at\")\n    context_object_name = \"articles\"\n</code></pre> <p>Try reloading again and this is what you should see:</p> Global feed in our app Global feed in the RealWorld app <p>It's starting to look like something! However we can improve the template a bit.</p>"},{"location":"02_home_page/#breaking-templates-into-subtemplates","title":"Breaking templates into subtemplates","text":"<p>We want to keep our templates as modular as possible, to simplify the structure of our project and make it easier to think about.</p> <p>The structure of the Svelte implementation makes a lot of sense and avoids us having to reinvent the wheel, so we'll take advantage of it.</p> <p>Specifically, we will copy the Svelte implementation's ArticleList structure by moving the whole <code>{% if articles|length_is:\"0\" %}...{% endif %}</code> clause HTML out of <code>templates/home.html</code> and into two separate files.</p> <p>In <code>templates/home.html</code>, we remove the <code>if</code> clause and replace it with an <code>include</code> tag:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;div class=\"container page\"&gt;\n  &lt;div class=\"row\"&gt;\n    &lt;div class=\"col-md-9\"&gt;\n      &lt;!-- {% if articles|length_is:\"0\" %}...{% endif %} --&gt;    &lt;!-- from this --&gt;\n      {% include \"article_list.html\" %}                         &lt;!-- to this --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>We create <code>templates/article_list.html</code> and add the code that we removed earlier, except the contents of the <code>for</code> clause:</p> <pre><code>{% if articles|length_is:\"0\" %}\n  &lt;div class=\"article-preview\"&gt;\n    No articles are here... yet.\n  &lt;/div&gt;\n{% else %}\n  &lt;div&gt;\n    {% for article in articles %}\n      {% include \"article_preview.html\" %}\n    {% endfor %}\n  &lt;/div&gt;\n{% endif %}\n</code></pre> <p>The <code>templates/article_preview.html</code> template will contain the remaining code:</p> <pre><code>&lt;div class=\"article-preview\"&gt;\n  &lt;div class=\"article-meta\"&gt;\n    &lt;div class=\"info\"&gt;\n      &lt;span class=\"author\"&gt;\n        {{ article.author.user.username }}\n      &lt;/span&gt;\n      &lt;span class=\"date\"&gt;\n        {{ article.created_at|date:\"D M d Y\" }}\n      &lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;a href=\"\" class=\"preview-link\"&gt;\n    &lt;h1&gt;{{ article.title }}&lt;/h1&gt;\n    &lt;p&gt;{{ article.description }}&lt;/p&gt;\n    &lt;span&gt;Read more...&lt;/span&gt;\n  &lt;/a&gt;\n&lt;/div&gt;\n</code></pre> <p>Reload the Conduit app to check that everything's still working.</p>"},{"location":"02_home_page/#navbar","title":"Navbar","text":"<p>Let's create a simple navigation bar now. Because we have yet to implement authentication and profiles, the navbar will just contain a link to <code>Home</code>, the page we just finished building.</p> <p>Let's add the following lines to <code>templates/base.html</code>:</p> <pre><code>&lt;body&gt;\n  {% include \"nav.html\" %}              &lt;!-- new --&gt;\n  &lt;main&gt;\n    {% block content %}\n    {% endblock %}\n  &lt;/main&gt;\n&lt;/body&gt;\n</code></pre> <p>Let's create <code>templates/nav.html</code> and add the following to it (copying Svelte's Nav.svelte template):</p> <pre><code>&lt;nav class=\"navbar navbar-light\"&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;a rel=\"prefetch\" class=\"navbar-brand\" href=\"/\"&gt;conduit&lt;/a&gt;\n    &lt;ul class=\"nav navbar-nav pull-xs-right\"&gt;\n      &lt;li class=\"nav-item\"&gt;\n        &lt;a href=\"{% url 'home' %}\" rel=\"prefetch\" class=\"nav-link\"&gt;\n          Home\n        &lt;/a&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/nav&gt;\n</code></pre> <p>The <code>url</code> tag is new to us: it enables us to specify URLs by name, instead of writing them every time we need to make a link in our HTML.</p> <p>In this case, we want our navbar to redirect users to the <code>Home</code> view, which is matched by the URL named <code>home</code> (as specified in <code>articles/urls.py</code>).</p> <p>Try clicking on the link: your page should reload (because you're redirected to it).</p>"},{"location":"03_viewing_articles/","title":"Viewing Articles","text":""},{"location":"03_viewing_articles/#introduction","title":"Introduction","text":"<p>In this chapter, we'll let our users navigate to and read individual articles.</p>"},{"location":"03_viewing_articles/#article-view","title":"Article view","text":"<p>First, we need to implement the article view.</p> <p>First, we create a view in <code>views.py</code>:</p> <pre><code>from django.views.generic import DetailView, ListView       # new\n\n# ...\n\nclass ArticleDetailView(DetailView):\n    \"\"\"Detail view for individual articles.\"\"\"\n\n    model = Article\n    template_name = \"article_detail.html\"\n</code></pre> <p>We're continuing to work with class-based views here. The <code>DetailView</code> generic display view allows to view a single instance of an object. We specify the model this view will be associated to and the template name.</p>"},{"location":"03_viewing_articles/#article-urls-and-primary-keys","title":"Article URLs and primary keys","text":"<p>We now match a URL to the <code>ArticleDetailView</code> in <code>articles/urls.py</code>:</p> <pre><code>from .views import ArticleDetailView, Home                                              # new\n\nurlpatterns = [\n    path(\"\", Home.as_view(), name=\"home\"),\n    path(\"article/&lt;int:pk&gt;\", ArticleDetailView.as_view(), name=\"article_detail\"),       # new\n]\n</code></pre> <p>This is the first time we're actually specifying a URL with arguments.</p> <p>Django's URL dispatcher docs have a lot of information on the ins and outs, but for now we only need to know that the current URL comprises an <code>articles/</code> prefix and the article's key.</p> <p>The <code>&lt;int:pk&gt;</code> parameter here matches any integer, and transfers the captured value to <code>ArticleDetailView</code>, which tries to identify the article based on its primary key (<code>pk</code>): primary keys are a way to uniquely specify a record in a database. Since we didn't specify how to generate primary keys for the <code>Article</code> objects in our database, this will default to an incrementing integer (the first article will have a <code>pk</code> of 1, the next will have a <code>pk</code> of 2, etc.).</p> <p>To have an idea, and to practice your shell skills, launch the interactive shell (by running <code>python manage.py shell</code>) and run the following commands:</p> <pre><code>In [1]: from conduit.articles.models import Article\n\nIn [2]: Article.objects.all()\nOut[2]: &lt;QuerySet [&lt;Article: ForeignKey&gt;, &lt;Article: ManyToManyField&gt;, &lt;Article: OneToOneField&gt;]&gt;\n\nIn [3]: Article.objects.first().pk\nOut[3]: 1\n\nIn [4]: Article.objects.last().pk\nOut[4]: 3\n</code></pre> <p>The concept of incrementing integers as the primary key has several flaws, the main one being that anyone can infer how many articles you publish, how many users you have, etc. just by looking at the URL. And the URLs are plain unclear. We'll change the primary keys later on.</p>"},{"location":"03_viewing_articles/#get_absolute_url-method","title":"get_absolute_url method","text":"<p>In order for <code>ArticleDetailView</code> to be able to identify an <code>Article</code> object from its <code>pk</code>, we need to modify the <code>Article</code> model in <code>articles/models.py</code> (don't forget to sync the database immediately after):</p> <pre><code>from django.db import models\nfrom django.shortcuts import reverse                                # new\n\n\nclass Article(models.Model):\n    \"\"\"Article model.\"\"\"\n\n    # ...\n\n    def get_absolute_url(self):                                     # new\n        return reverse(\"article_detail\", kwargs={\"pk\": self.pk})    #\n</code></pre> <p>The <code>get_absolute_url</code> method tells Django how to generate the URL for the instance. The <code>reverse</code> function takes a <code>urlpattern</code> (<code>article_detail</code> here), required kwargs (the instance's <code>pk</code> here), and returns a URL, which avoids having to hardcode it.</p> <p>You can have a look at how it works in the shell:</p> <pre><code>In [1]: from conduit.articles.models import Article\n\nIn [2]: from django.urls import reverse\n\nIn [3]: article = Article.objects.first()\n\nIn [4]: reverse('article_detail', kwargs={'pk': article.pk})\nOut[4]: '/article/1'\n</code></pre>"},{"location":"03_viewing_articles/#article-templates","title":"Article templates","text":"<p>Like in the previous chapter, after making a view and setting the URL, we will now work on templates.</p>"},{"location":"03_viewing_articles/#article_detailhtml","title":"article_detail.html","text":"<p>We create the <code>templates/article_detail.html</code> template with the following code:</p> <pre><code>{% extends \"base.html\" %}\n{% block title %}\n  &lt;title&gt;{{ article.title }} - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n  &lt;div class=\"article-page\"&gt;\n    &lt;div class=\"banner\"&gt;\n      &lt;div class=\"container\"&gt;\n        &lt;h1&gt;{{ article.title }}&lt;/h1&gt;\n        {% include \"article_meta.html\" %}\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"container page\"&gt;\n      &lt;div class=\"row article-content\"&gt;\n        &lt;div class=\"col-xs-12\"&gt;\n          &lt;div&gt;\n            {{ article.body|linebreaks }}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>Not much to explain:</p> <ul> <li>we're overriding the <code>title</code> block of <code>base.html</code> with a <code>{% block title %}</code> to display the title of the article (and our app's name): this is an illustration of template inheritance, which we mentioned earlier</li> <li>in the <code>content</code> block of <code>base.html</code>:</li> <li>we refer to our object as <code>article</code>: the default <code>context_object_name</code> variable (the way you refer to the object that the view is manipulating) in for <code>DetailView</code> (among others) is the model's name (<code>Article</code>) in lowercase</li> <li>we're showing the article's title</li> <li>we're including a <code>templates/article_meta.html</code> template simply because we're following Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/%5Bslug%5D/index.svelte][article/[slug]/index.svelte]] and we might as well keep to their structure if you ever need to quickly compare things</li> <li>the <code>linebreaks</code> template filter ensures that the line breaks in our articles are properly translated to HTML and rendered.</li> </ul>"},{"location":"03_viewing_articles/#article_metahtml","title":"article_meta.html","text":"<p>We create <code>templates/article_meta.html</code>, based on the Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_ArticleMeta.svelte][_ArticleMeta.svelte]]:</p> <pre><code>&lt;div class=\"article-meta\"&gt;\n  &lt;div class=\"info\"&gt;\n    &lt;span class=\"author\"&gt;\n      {{ article.author.user.username }}\n    &lt;/span&gt;\n    &lt;span class=\"date\"&gt;\n      {{ article.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>We display the author's username and the article's creation date (properly formatted with the <code>date</code> template filter).</p>"},{"location":"03_viewing_articles/#article_previewhtml","title":"article_preview.html","text":"<p>Finally, we modify <code>template/article_preview.html</code> so that article previews redirect to the full articles:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;!-- &lt;a href=\"\" rel=\"prefetch\" class=\"preview-link\"&gt; --&gt;                        &lt;!-- from this --&gt;\n&lt;a href=\"{{ article.get_absolute_url }}\" rel=\"prefetch\" class=\"preview-link\"&gt;   &lt;!-- to this --&gt;\n   &lt;h1&gt;{{ article.title }}&lt;/h1&gt;\n   &lt;p&gt;{{ article.description }}&lt;/p&gt;\n   &lt;span&gt;Read more...&lt;/span&gt;\n&lt;/a&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>We implemented the <code>get_absolute_url</code> method in our <code>Article</code> model earlier, which allows to specify the URLs to instances by calling the instance's <code>get_absolute_url</code> method.</p>"},{"location":"03_viewing_articles/#results","title":"Results","text":"<p>Seems like we're ready, doesn't it? If you try to navigate to an article in your Conduit app, you should be able to view your articles.</p> <p>Let's see what it looks like:</p> Individual article in our app Individual article in RealWorld app <p>Getting pretty close!</p>"},{"location":"04_slugs/","title":"Slugs","text":""},{"location":"04_slugs/#introduction","title":"Introduction","text":"<p>We mentioned earlier that we didn't like having incrementing integers as primary keys for our articles, and we liked even less exposing these keys in the URL.</p> <p>We want our article URLs to include slugs, which are easier to read than IDs.</p> <p>We want the slugs to be unique, but some articles might have the same titles, which would generate the same slugs. One solution to this problem is to combine slugs with UUIDs.</p> <p>Before continuing:</p> <ul> <li>slugs are the result of converting a string of text (generally a title) to a form that can be included in a URL: this generally consists in converting spaces to hyphens, removing special characters, and converting to lowercase</li> <li>a universally unique identifier (UUID) is a string of text expected to have an extremely low probability of duplication, without requiring a central authority to create them</li> </ul>"},{"location":"04_slugs/#define-slug-and-uuid-fields-in-the-model","title":"Define slug and UUID fields in the model","text":"<p>First, we need to modify our <code>Article</code> model to include <code>slug_uuid</code> and <code>uuid_field</code> fields in <code>articles/models.py</code>:</p> <pre><code># ...\nimport uuid                                                                     # new\n\n\nclass Article(models.Model):\n    # ...\n    slug_uuid = models.SlugField(max_length=100, editable=False)                # new\n    uuid_field = models.UUIDField(default=uuid.uuid4, editable=False)           # new\n</code></pre> <p>We make both the <code>slug_uuid</code> and <code>uuid_field</code> uneditable because editing these fields is too error-prone to be facilitated (though admins will always be able to revert this temporarily if they need to).</p> <p>After modifying the model, we need to sync the database, but this will return a warning.</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# It is impossible to add a non-nullable field 'slug_uuid' to article without specifying a default. This is because the database needs something to populate existing rows.\n# Please select a fix:\n#  1) Provide a one-off default now (will be set on all existing rows with a null value for this column)\n#  2) Quit and manually define a default value in models.py.\n# Select an option:\n</code></pre> <p>Selecting <code>1</code> would have little value: a default is by definition non-unique, so we'll have to go and edit it later anyway. We select <code>2</code> to abort and add the <code>null=True</code> argument to the <code>slug_uuid</code> field: the field will become nullable (so the migration will be able to set 0 as default) and editable (so we'll be able to modify it manually through the Django admin):</p> <pre><code>class Article(models.Model):\n    # ...\n    # slug_uuid = models.SlugField(max_length=100, editable=False)      # from this\n    slug_uuid = models.SlugField(max_length=100, null=True)             # to this\n    # ...\n</code></pre> <p>We run <code>makemigrations</code> and <code>migrate</code>:</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# Migrations for 'articles':\n#   conduit/articles/migrations/0002_article_slug_uuid_article_uuid_field.py\n#     - Add field slug_uuid to article\n#     - Add field uuid_field to article\n(django) django_tutorial$ python manage.py migrate\n# Operations to perform:\n#   Apply all migrations: admin, articles, auth, contenttypes, sessions, users\n# Running migrations:\n#   Applying articles.0002_article_slug_uuid_article_uuid_field... OK\n</code></pre> <p>No error. We can go the Django admin, then set a unique slug for each <code>Article</code> manually: you can just slugify the titles you came up by hand, so \u201cMaking Slugs by Hand\u201d would become \u201cmaking-slugs-by-hand\u201d for example.</p> Editing slugs <p>Once we're done, we return to <code>articles/models.py</code> to remove the <code>null=True</code> argument and add the <code>editable=False</code> argument to <code>slug_uuid</code> again:</p> <pre><code>class Article(models.Model):\n    # ...\n    # slug_uuid = models.SlugField(max_length=100, null=True)           # from this\n    slug_uuid = models.SlugField(max_length=100, editable=False)        # to this\n    # ...\n</code></pre> <p>When you make the migrations, you'll get a warning:</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# It is impossible to change a nullable field 'slug_uuid' on article to non-nullable without providing a default. This is because the database needs something to populate existing rows.\n# Please select a fix:\n#  1) Provide a one-off default now (will be set on all existing rows with a null value for this column)\n#  2) Ignore for now. Existing rows that contain NULL values will have to be handled manually, for example with a RunPython or RunSQL operation.\n#  3) Quit and manually define a default value in models.py.\n# Select an option: 2\n# Migrations for 'articles':\n#   conduit/articles/migrations/0003_alter_article_slug_uuid.py\n#     - Alter field slug_uuid on article\n</code></pre> <p>You can safely select <code>2</code>, as we have already taken care of the <code>slug_uuid</code> fields through the Django admin app.</p>"},{"location":"04_slugs/#display-slug-and-uuid-fields-in-the-django-admin","title":"Display slug and UUID fields in the Django admin","text":"<p>It'd be nice to be able to view our new fields in the Django admin, but non-editable fields are hidden by default.</p> <p>In order to display these fields, we need to override how the Django admin represents the <code>Article</code> model.</p> <p>In <code>articles/admin.py</code>, add the following:</p> <pre><code>#...\n\nclass ArticleAdmin(admin.ModelAdmin):               # new\n    readonly_fields = (\"slug_uuid\", \"uuid_field\")   #\n\n\n# admin.site.register(Article)                      # from this\nadmin.site.register(Article, ArticleAdmin)          # to this\n</code></pre> <p>Here, we define subclass a <code>ModelAdmin</code> class (which defines how a model is represented in the Django admin) and add the non-editable fields we want to see to the new class's <code>readonly_fields</code> attribute.</p> <p>If you have a look at some of the existing articles, you'll be able to see their <code>slug_uuid</code> and <code>uuid_field</code> fields now.</p>"},{"location":"04_slugs/#generate-unique-slug_uuid-fields-with-utility-functions","title":"Generate unique <code>slug_uuid</code> fields with utility functions","text":"<p>We want to avoid manually entering the slugs for every article: the generation of a unique <code>slug_uuid</code> should be triggered automatically every time an <code>Article</code> instance is saved. Because our choice of slug is not the simplest, it doesn't come included with Django: we will need to create this functionality.</p> <p>When we need to define new functions in order to add some new functionality to Django, the common pattern is to create a utility module (generally a <code>utils.py</code> file) and import the functions from there. This enables reuse, allows to keep code in models and views short, and facilitates testing. Depending on the scope of the utility functions, <code>utils.py</code> can be placed within the project, or simply at the level of the app.</p> <p>In our case, we only need a function that will create unique slugs for articles, the scope of the utility module is the <code>articles</code> app, so we create the <code>utils.py</code> file in the <code>articles</code> folder:</p> <pre><code>from django.utils.text import slugify\n\n\ndef slug_uuid_generator(instance):\n    \"\"\"Generate a unique slug_uuid for Articles from the title and a UUID.\"\"\"\n    # if the instance already has a `slug_uuid`, don't change it\n    # to avoid changing URLs\n    if instance.slug_uuid:\n        return instance.slug_uuid\n\n    # get the instance's class (`Article`)\n    ArticleClass = instance.__class__\n\n    # get max length of `slug_uuid` as defined in the `Article` model\n    max_length = ArticleClass._meta.get_field(\"slug_uuid\").max_length\n\n    uuid_field = str(instance.uuid_field)\n    uuid_length = len(uuid_field)\n\n    # slugify instance's title\n    # trim slug to leave space for UUID\n    slug_field = slugify(instance.title)[: max_length - uuid_length - 1]\n\n    # create `slug_uuid` by concatenating slugified title and UUID\n    slug_uuid = \"{slug_field}-{uuid_field}\".format(\n        slug_field=slug_field,\n        uuid_field=uuid_field,\n    )\n\n    return slug_uuid\n</code></pre> <p>This looks complicated, because it is, at our current level.</p> <p>What we want to happen is the following: when a new article (ie a new instance of the <code>Article</code> model) is saved, we want a function to take that instance as an argument, extract its title and UUID, slugify the title, concatenate the slug with the UUID, and set the resulting string as that instance's <code>slug_uuid</code> field value. There's also a condition: if the article already has a <code>slug_uuid</code> (and is being saved after a simple update), then we don't want to change the <code>slug_uuid</code>, because that would change the URL and cool URLs don't change.</p> <p>Walking through the function step by step, you can check that it is exactly what we're doing.</p>"},{"location":"04_slugs/#override-save-method-instead-of-creating-signals-alternative","title":"Override <code>save</code> method instead of creating signals (alternative)","text":"<p>One way to call <code>slug_uuid_generator</code> at the moment of saving an article would be to override the <code>Article</code> model's <code>save</code> method: this is a common method, but not best practice.</p> <p>The next section is rather complicated, so if you prefer to keep things simple for now, you can just add the code below to your <code>articles/models.py</code> and skip straight to Adapt URLs and views to <code>slug_uuid</code> fields:</p> <pre><code># ...\nfrom .utils import slug_uuid_generator              # new\n\n\nclass Article(models.Model):\n    # ...\n\n    def save(self, *args, **kwargs):                # new\n        self.slug_uuid = slug_uuid_generator(self)  #\n        super().save(*args, **kwargs)               #\n</code></pre> <p>We advise you to implement signals instead however, both in order to get some of that sweet Django learning, but also because this method will keep your code readable when your <code>save</code> method overrides start being 50 lines long.</p>"},{"location":"04_slugs/#generate-slug_uuid-fields-automatically-with-signals","title":"Generate <code>slug_uuid</code> fields automatically with signals","text":"<p>The function in the <code>utils.py</code> file should be called at the moment of saving a new <code>Article</code> instance: this step does not happen in the <code>utils.py</code> file, but in the file we will create next.</p> <p>We create the <code>articles/signals.py</code> file and add the following method to it:</p> <pre><code>from django.db.models.signals import pre_save\nfrom django.dispatch import receiver\n\nfrom .models import Article\nfrom .utils import slug_uuid_generator\n\n\n@receiver(pre_save, sender=Article)\ndef generate_slug_uuid_before_article_save(sender, instance, *args, **kwargs):\n    \"\"\"Call slug_uuid_generator function when saving `Article` instance.\"\"\"\n    instance.slug_uuid = slug_uuid_generator(instance)\n</code></pre> <p>We use a signal to call our <code>slug_uuid_generator</code> every time an <code>Article</code> instance is created. Signals are a Django utility that allows applications (\u201creceivers\u201d) within Django to be notified (by \u201csenders\u201d) when certain actions happen.</p> <p>In this case, the sender is the <code>Article</code> model. We want our <code>slug_uuid</code> to be generated just before an article is saved, so we want to use the <code>pre_save</code> signal, which is sent before a model's <code>save</code> method is called.</p> <p>The receiver function <code>pre_save_receiver</code> generates a <code>slug_uuid</code> by calling <code>slug_uuid_generator</code>. We specify that <code>pre_save_receiver</code> is the receiver with the receiver decorator.</p> <p>In order to activate this signal, we will modify <code>articles/apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\n\nclass ArticlesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"conduit.articles\"\n\n    def ready(self):                        # new\n        import conduit.articles.signals     # new\n</code></pre> <p>The <code>ready</code> method allows us to register the signals, and because we are using a <code>receiver</code> decorator, the signal handlers are connected implicitly by just importing them.</p> <p>We're ready to test our <code>slug_uuid</code> generation: let's try creating an Article through the Django admin app. Write some placeholder text in the title, description, and body, then select your superuser as the author, and save: you should be able to see the article in the Django admin and you can check that it has a nice <code>slug_uuid</code> value. Try changing the title of that article, save, and check that the <code>slug_uuid</code> has not changed.</p>"},{"location":"04_slugs/#adapt-urls-and-views-to-slug_uuid-fields","title":"Adapt URLs and views to <code>slug_uuid</code> fields","text":"<p>Since we want to have <code>slug_uuid</code> parameters in our articles' URLs, we need to change <code>urlpatterns</code> in <code>articles/urls.py</code>:</p> <pre><code># ...\nurlpatterns = [\n    # ...\n    # path(\"article/&lt;int:pk&gt;\", ArticleDetailView.as_view(), name=\"article_detail\"),     # from this\n    path(                                                                               # to this\n        \"article/&lt;slug:slug_uuid&gt;\", ArticleDetailView.as_view(), name=\"article_detail\"  #\n    ),                                                                                  #\n]\n</code></pre> <p>Here, we tell Django's URL dispatcher to call the <code>ArticleDetailView</code> with the <code>slug_uuid</code> parameter, which is matched by the <code>slug</code> path converter in the URL.</p> <p>We're not finished just yet: if you navigate to your Conduit app at http://127.0.0.1:8000/ and hover over the article previews, you'll see that the hyperlinks still point to URLs with a <code>pk</code> value. To remedy this, we need to update the <code>get_absolute_url</code> method in <code>articles/models.py</code>, so that our links in templates specify URLs with the article's <code>slug_uuid</code> value:</p> <pre><code># ...\n\nclass Article(models.Model):\n    # ...\n    def get_absolute_url(self):\n        # return reverse(\"article_detail\", kwargs={\"pk\": self.pk})              # from this\n        return reverse(\"article_detail\", kwargs={\"slug_uuid\": self.slug_uuid})  # to this\n</code></pre> <p>If you try to view a specific article now, you should get the following error:</p> <p>AttributeError at /article/onetoonefield</p> <p>Generic detail view ArticleDetailView must be called with either an object pk or a slug in the URLconf.</p> <p>Request Method: GET Request URL: http://127.0.0.1:8000/article/onetoonefield</p> <p>This means that our <code>ArticleDetailView</code>, which is the interface that allows to identify the relevant model instance given a specific URL, is expecting either a <code>pk</code> or a <code>slug</code> parameter.</p> <p>We have a few options:</p> <ul> <li>we can simply rename our <code>slug_uuid</code> fields to <code>slug</code> and be done with it</li> <li>we can teach our <code>ArticleDetailView</code> to identify <code>Article</code> instances based on the <code>slug_uuid</code> field</li> </ul> <p>By now, you probably know that we're obviously going to choose the\u2026 second, more complicated option. Because we'll learn more that way.</p> <p>In <code>articles/views.py</code>:</p> <pre><code>#...\nfrom django.shortcuts import get_object_or_404                  # new\n\nclass ArticleDetailView(DetailView):\n    # ...\n    def get_object(self):                                       # new\n        slug_uuid = self.kwargs.get(\"slug_uuid\")                #\n        return get_object_or_404(Article, slug_uuid=slug_uuid)  #\n</code></pre> <p>Looks complicated, doesn't it? Wish we had chosen the easy way out. Anyway, let's try to understand.</p> <p>When the URL dispatcher gets a request at a specific URL, it passes the data from the request (the URL itself, whether the user's logged in, whether the user's on a premium plan, etc.) to the view. Inside the view, we can access this data. The request data is included into the <code>self</code> argument that the <code>get_object</code> method gets. From the request, we can extract the keyword arguments, or the kwargs. We're interested in the <code>slug_uuid</code> kwarg, specifically. Once we have the <code>slug_uuid</code> value, we can retrieve the desired <code>Article</code> model instance.</p> <p>When going back to http://localhost:8000/ (where your app is running), you will see that your new article has a <code>slug_uuid</code> consisting of its slugified title and a UUID:</p> <code>slug_uuid</code> fields"},{"location":"04_slugs/#slug-and-uuid_field-instead-of-slug_uuid-alternative","title":"<code>slug</code> and <code>uuid_field</code> instead of <code>slug_uuid</code> (alternative)","text":"<p>We have seen how to override the way instances of a model are retrieved by Django, but there is also a much simpler alternative to what we just did. Making slugs and UUIDs is a common requirement, so Django facilitates tasks around working with such fields.</p> <p>The code below assumes that we are back to the very start of this chapter, just after finishing the Viewing Articles chapter.</p> <p>In our <code>articles/models.py</code>, we create <code>slug</code> and <code>uuid_field</code> fields (we have to specify <code>null=True</code>, create <code>slug</code> values for the existing articles, then specify <code>editable=False</code>, like we did above):</p> <pre><code># ...\nimport uuid                                                                     # new\n\n\nclass Article(models.Model):\n    # ...\n    slug = models.SlugField(max_length=68, editable=False)                      # new\n    uuid_field = models.UUIDField(default=uuid.uuid4, editable=False)           # new\n</code></pre> <p>Still in <code>articles/models.py</code>, we override the <code>save</code> method to generate slugs at save:</p> <pre><code># ...\nfrom django.utils.text import slugify                                           # new\n\n\nclass Article(models.Model):\n    # ...\n\n    def save(self, *args, **kwargs):                                            # new\n        self.slug = slugify(self.title)                                         # new\n        super().save(*args, **kwargs)                                           # new\n</code></pre> <p>In <code>articles/urls.py</code>, we add our new URL:</p> <pre><code># ...\nurlpatterns = [\n    # path(\"article/&lt;int:pk&gt;\", ArticleDetailView.as_view(), name=\"article_detail\"),                 # from this\n    path(                                                                                           # to this\n        \"article/&lt;slug:slug&gt;-&lt;uuid:uuid&gt;\",                                                          #\n        ArticleDetailView.as_view(),                                                                #\n        name=\"article_detail\",                                                                      #\n    ),                                                                                              #\n]\n</code></pre> <p>In <code>articles/models.py</code>, we adapt <code>get_absolute_url</code>:</p> <pre><code># ...\n\nclass Article(models.Model):\n    # ...\n    def get_absolute_url(self):\n        # return reverse(\"article_detail\", kwargs={\"pk\": self.pk})                  # from this\n        return reverse(                                                             # to this\n            \"article_detail\", kwargs={\"slug\": self.slug, \"uuid\": self.uuid_field}   #\n        )                                                                           #\n</code></pre> <p>And finally we adapt the view in <code>articles/views.py</code>:</p> <pre><code>#...\nfrom django.shortcuts import get_object_or_404                                  # new\n\nclass ArticleDetailView(DetailView):\n    # ...\n    def get_object(self):                                                       # new\n        slug = self.kwargs.get(\"slug\")                                          #\n        uuid_field = self.kwargs.get(\"uuid\")                                    #\n        return get_object_or_404(Article, slug=slug, uuid_field=uuid_field)     #\n</code></pre>"},{"location":"05_creating_editing_and_deleting_articles/","title":"Creating, editing, and deleting Articles","text":""},{"location":"05_creating_editing_and_deleting_articles/#introduction","title":"Introduction","text":"<p>We have implemented the features that allow us to view articles, but up to now we've been modifying them through the Django admin. We need to let our users create, edit, and delete articles.</p> <p>Technically, these functionalities should only be available to logged-in users, but that's not something we can work on just yet, so we will go ahead and implement the article features, and modify them later in order to take into account user authentication.</p>"},{"location":"05_creating_editing_and_deleting_articles/#creating-articles","title":"Creating articles","text":"<p>Let's allow users to create articles. The most basic feature possible.</p> <p>Advice</p> <p>We remind you again that up to now we've mostly been keeping to the DjangoGirls tutorial: if you're having difficulties following, you should do that tutorial instead, as its pace is a bit slower. Unless, of course, the fault is on my side of the screen, in which case please provide feedback :).</p>"},{"location":"05_creating_editing_and_deleting_articles/#subclass-a-createview","title":"Subclass a <code>CreateView</code>","text":"<p>Creating instances of a model is bound to be a common task, right? Unsurprisingly, Django has a ready-made class-based view for that.</p> <p>We subclass a <code>CreateView</code> in <code>articles/views.py</code>:</p> <pre><code># ...\nfrom django.views.generic import CreateView, DetailView, ListView   # new\n\n# ...\n\nclass EditorCreateView(CreateView):                                 # new\n    \"\"\"View for creating articles.\"\"\"                               #\n                                                                    #\n    model = Article                                                 #\n    fields = ['title', 'description', 'body']                       #\n    template_name = \"editor.html\"                                   #\n</code></pre> <p>The <code>CreateView</code> class-based view is a generic editing view that \u201cdisplays a form for creating an object, redisplaying the form with validation errors (if there are any) and saving the object\u201d. What more could we want? Sometimes, using class-based views (and Django in general) might feel like a cheat code, but it's completely legal, don't worry.</p> <p>In the code above, we specify the following:</p> <ul> <li>the model that we're creating new instances of</li> <li>the template name</li> <li>the fields we want to have available to the user when creating the form: specifically, we're leaving out the <code>author</code> field here.</li> </ul>"},{"location":"05_creating_editing_and_deleting_articles/#add-a-urlpattern","title":"Add a <code>urlpattern</code>","text":"<p>We add the following to <code>articles/urls.py</code>:</p> <pre><code># ...\nfrom .views import ArticleDetailView, EditorCreateView, Home            # new\n\nurlpatterns = [\n    # ...\n    path(\"editor\", EditorCreateView.as_view(), name=\"editor_create\"),   # new\n]\n</code></pre> <p>Not much to explain here.</p>"},{"location":"05_creating_editing_and_deleting_articles/#create-a-form","title":"Create a form","text":"<p>This section will have lots of new elements and information, so take a break.</p> <p>We need to create the template <code>templates/editor.html</code> (based on Svelte implementation's _Editor.svelte template):</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n  &lt;title&gt;Editor - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n  &lt;div class=\"editor-page\"&gt;\n    &lt;div class=\"container page\"&gt;\n      &lt;div class=\"row\"&gt;\n        &lt;div class=\"col-md-10 offset-md-1 col-xs-12\"&gt;\n          &lt;form method=\"post\"&gt;\n            {% csrf_token %}\n            &lt;fieldset&gt;\n              {{ form.non_field_errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control form-control-lg\"\n                  type=\"text\"\n                  placeholder=\"Article Title\"\n                  name=\"{{ form.title.name }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ form.title.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control\"\n                  type=\"text\"\n                  placeholder=\"What's this article about?\"\n                  name=\"{{ form.description.name }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ form.description.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;textarea\n                  class=\"form-control\"\n                  rows=\"8\"\n                  placeholder=\"Write your article (in markdown)\"\n                  name=\"{{ form.body.name }}\"\n                &gt;&lt;/textarea&gt;\n              &lt;/fieldset&gt;\n              {{ form.body.errors }}\n              &lt;button class=\"btn btn-lg pull-xs-right btn-primary\"&gt;\n                Publish Article\n              &lt;/button&gt;\n            &lt;/fieldset&gt;\n          &lt;/form&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>There's a lot here: we've reached the point where we have to implement forms, a major use case in web dev. While forms are one of Django's many strong points, there is a lot of new material to understand.</p> <p>The Django docs section that deals with forms says:</p> <p>Django handles three distinct parts of the work involved in forms:</p> <ul> <li>preparing and restructuring data to make it ready for rendering</li> <li>creating HTML forms for the data</li> <li>receiving and processing submitted forms and data from the client</li> </ul> <p>Forms allow users to provide input to the website they're visiting, that the website can then process and act upon.</p> <p>We want to modify data server-side (we will create new <code>Article</code> instances), so we need to make a POST form (which we do with <code>method=\"post\"</code>).</p> <p>POST forms need to mitigate against Cross Site Request Forgeries, a type of malicious attack, but Django makes this very easy: in our case, we only need to include the <code>{% csrf_token %}</code> tag inside the <code>&lt;form&gt;</code> element (though you might have to do a bit more work in other circumstances).</p> <p>There are different ways to render a form: it depends on whether Django's defaults unpacking of form fields is sufficient, or whether you need more flexibility in how you render the fields. In our case, we want a lot of flexibility: we want the fields to be in a specific order, to have distinct placeholder values, to have different CSS styling, etc., so we'll render them manually.</p> <p>Because we chose to render form fields manually, we also have to render form errors manually. The <code>{{ form.non_field_errors }}</code> variable will display any errors that are not field-specific, which is why this variable is outside of any fieldsets. The <code>{{ form.field_name.errors }}</code> variables, located in the relevant fieldset tag, will display field-specific errors.</p>"},{"location":"05_creating_editing_and_deleting_articles/#add-a-navbar-button","title":"Add a navbar button","text":"<p>We add a <code>New article</code> button to the Nav bar in <code>templates/nav.html</code> (still copying Svelte's Nav.svelte template):</p> <pre><code>&lt;!-- ... --&gt;\n&lt;ul class=\"nav navbar-nav pull-xs-right\"&gt;\n  &lt;li class=\"nav-item\"&gt;\n    {% url 'home' as home %}                                                        &lt;!-- new --&gt;\n    &lt;!-- &lt;a href=\"{% url 'home' %}\" rel=\"prefetch\" class=\"nav-link\"&gt; --&gt;            &lt;!-- from this --&gt;\n    &lt;a                                                                              &lt;!-- to this --&gt;\n      href=\"{{ home }}\"                                                             &lt;!-- # --&gt;\n      rel=\"prefetch\"                                                                &lt;!-- # --&gt;\n      class=\"nav-link {% if request.path == home %}active{% endif %}\"               &lt;!-- # --&gt;\n    &gt;                                                                               &lt;!-- # --&gt;\n      Home\n    &lt;/a&gt;\n  &lt;/li&gt;\n  &lt;li class=\"nav-item\"&gt;                                                             &lt;!-- new --&gt;\n    {% url 'editor_create' as editor_create %}                                      &lt;!-- # --&gt;\n    &lt;a                                                                              &lt;!-- # --&gt;\n      href=\"{{ editor_create }}\"                                                    &lt;!-- # --&gt;\n      rel=\"prefetch\"                                                                &lt;!-- # --&gt;\n      class=\"nav-link {% if request.path == editor_create %}active{% endif %}\"      &lt;!-- # --&gt;\n    &gt;                                                                               &lt;!-- # --&gt;\n      &lt;span class=\"ion-compose\"&gt;                                                    &lt;!-- # --&gt;\n        New Post                                                                    &lt;!-- # --&gt;\n      &lt;/span&gt;                                                                       &lt;!-- # --&gt;\n    &lt;/a&gt;                                                                            &lt;!-- # --&gt;\n  &lt;/li&gt;                                                                             &lt;!-- # --&gt;\n&lt;/ul&gt;\n</code></pre> <p>Now that we have 2 links in our navbar, we want to better style active links: we add <code>{% url 'home' as home %}</code> and <code>class \"nav-link {% if request.path == home %}active{% endif %}\"</code>.</p>"},{"location":"05_creating_editing_and_deleting_articles/#override-form_valid","title":"Override <code>form_valid</code>","text":"<p>Try to create an article in your app. When you hit \u201cPublish\u201d, you'll get an error:</p> <p>IntegrityError at /editor NOT NULL constraint failed: articles_article.author_id</p> <p>This means that the issue is that the <code>author</code> value for the <code>Article</code> instance we're trying to create is <code>NULL</code>, which it shouldn't be. What we need to do in order to solve this issue is to somehow tell Django that the author is whoever's sending the request for creating the article: even though we haven't yet implemented authentication, we do have a user</p> <p>The docs tell us that, when we want to track the user that created an object with a <code>CreateView</code>, we need to override the view's <code>form_valid</code> method, which is called when some valid form data is POSTed.</p> <p>In <code>articles/views.py</code>, we override the <code>form_valid</code> method of our <code>EditorCreateView</code>, following the example given in the docs:</p> <pre><code># ...\nclass EditorCreateView(CreateView):\n    \"\"\"create article\"\"\"\n\n    model = Article\n    fields = [\"title\", \"description\", \"body\"]\n    template_name = \"editor.html\"\n\n    def form_valid(self, form):                         # new\n        self.object.author = self.request.user.profile  #\n        return super().form_valid(form)                 #\n</code></pre> <p>Should work now, right? As expected, when we try to create an article again, we get an\u2026 error again?</p> <p>AttributeError at /editor \u2018NoneType\u2019 object has no attribute \u2018author\u2019</p> <p>If we read our code again, we can pinpoint the issue to the fact that <code>self.object</code> does not exist. We need to create the object first.</p> <p>Solving this requires understanding a bit more about forms. Behind the scenes, when we subclass a <code>CreateView</code> because we want to create new instances of a specific model, the forms that we're working with when creating new model instances are <code>ModelForm</code> objects, which map a model class's fields to HTML form <code>&lt;input&gt;</code> elements.</p> <p>The <code>ModelForm</code> class has a <code>save</code> method which \u201ccreates and saves a database object from the data bound to the form\u201d. What we want to do is get that data, append a new field, then save the resulting object to the database. Well, we're in luck: /\u201cIf you call save() with commit=False, then it will return an object that hasn\u2019t yet been saved to the database. [\u2026] This is useful if you want to do custom processing on the object before saving it\u201d/.</p> <p>Let's try to take into account this new piece of knowledge:</p> <pre><code># ...\nclass EditorCreateView(CreateView):\n    \"\"\"create article\"\"\"\n\n    model = Article\n    fields = [\"title\", \"description\", \"body\"]\n    template_name = \"editor.html\"\n\n    def form_valid(self, form):\n        self.object = form.save(commit=False)           # new\n        self.object.author = self.request.user.profile\n        self.object.save()                              # new\n        return super().form_valid(form)\n</code></pre> <p>The code above does the following:</p> <ul> <li>get the object from the data POSTed by the form</li> <li>set the logged in <code>profile</code> (which will always be <code>admin</code>, for now) as the <code>author</code></li> <li>save the new object.</li> </ul> <p>Try creating another article once you have added the code above to your view: a new article will be created and you will be redirected to its page.</p> <p>Be aware however that you need to be logged in as admin for it to work, otherwise you'll get another error.</p>"},{"location":"05_creating_editing_and_deleting_articles/#editing-articles","title":"Editing articles","text":"<p>We will now implement the editing feature.</p>"},{"location":"05_creating_editing_and_deleting_articles/#subclass-an-updateview","title":"Subclass an <code>UpdateView</code>","text":"<p>You won't be surprised by now if we say that Django comes with a ready-made view for editing objects: the <code>UpdateView</code> class-based view.</p> <p>In <code>articles/views.py</code>, add the following:</p> <pre><code># ...\nfrom django.views.generic import CreateView, DetailView, ListView, UpdateView\n\n# ...\n\nclass EditorUpdateView(UpdateView):\n    \"\"\"View for editing articles.\"\"\"\n\n    model = Article\n    fields = [\"title\", \"description\", \"body\"]\n    template_name = \"editor.html\"\n</code></pre> <p>Nothing new here: we're going to be editing the <code>Article</code> model on the fields that we expose when creating new articles, and we'll use the same template for creating and editing articles.</p>"},{"location":"05_creating_editing_and_deleting_articles/#add-a-urlpattern_1","title":"Add a <code>urlpattern</code>","text":"<p>In <code>articles/urls.py</code>, add:</p> <pre><code># ...\nfrom .views import (\n    # ...\n    EditorUpdateView\n)\n\nurlpatterns = [\n    # ...\n    path(\"editor/&lt;slug:slug_uuid&gt;\", EditorUpdateView.as_view(), name=\"editor_update\"),\n]\n</code></pre> <p>Again, nothing new.</p>"},{"location":"05_creating_editing_and_deleting_articles/#adapt-editorhtml-template","title":"Adapt <code>editor.html</code> template","text":"<p>Now we need to adapt our existing <code>templates/editor.html</code> template for cases where we're updating, rather than creating, articles.</p> <p>In practice, this doesn't demand a lot of changes: we're still working on the same model, exposing the same fields, at the same URL.</p> <p>The only thing that changes is that we want to have the form fields empty when the object doesn't exist yet (ie we're creating an article), and we want these fields prepopulated with the relevant values if the object exists already (ie we're updating).</p> <p>Let's add the following to <code>templates/editor.html</code>:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;fieldset&gt;\n  {{ form.non_field_errors }}\n  &lt;fieldset class=\"form-group\"&gt;\n    &lt;input\n      class=\"form-control form-control-lg\"\n      type=\"text\"\n      placeholder=\"Article Title\"\n      name=\"{{ form.title.name }}\"\n      value=\"{{ form.title.value|default_if_none:'' }}\"            &lt;!-- new --&gt;\n    /&gt;\n  &lt;/fieldset&gt;\n  {{ form.title.errors }}\n  &lt;fieldset class=\"form-group\"&gt;\n    &lt;input\n      class=\"form-control\"\n      type=\"text\"\n      placeholder=\"What's this article about?\"\n      name=\"{{ form.description.name }}\"\n      value=\"{{ form.description.value|default_if_none:'' }}\"      &lt;!-- new --&gt;\n    /&gt;\n  &lt;/fieldset&gt;\n  {{ form.description.errors }}\n  &lt;fieldset class=\"form-group\"&gt;\n    &lt;textarea\n      class=\"form-control\"\n      rows=\"8\"\n      placeholder=\"Write your article (in markdown)\"\n      name=\"{{ form.body.name }}\"\n    &gt;{{ form.body.value|default_if_none:'' }}&lt;/textarea&gt;           &lt;!-- new --&gt;\n  &lt;/fieldset&gt;\n  {{ form.body.errors }}\n  &lt;button class=\"btn btn-lg pull-xs-right btn-primary\"&gt;\n    Publish Article\n  &lt;/button&gt;\n&lt;/fieldset&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>We are accessing the relevant values for our fields through <code>form.field_name.value</code>. However, when using <code>UpdateView</code>, we have access to the object being updated, so we have access to the relevant values through the <code>context_object_name</code> <code>article</code>, so you could write <code>article.title</code> instead of <code>form.title.value</code>, etc., if you prefer this alternative.</p> <p>We're using a <code>default_if_none</code> template filter here: this filter provides a default value if the value of the preceding variable is <code>None</code>. If our article exists, it will have a title, description, and body, and the values of those fields will be presented in the form fields. If the article doesn't exist, we will just get the empty strings we defined as default.</p>"},{"location":"05_creating_editing_and_deleting_articles/#add-an-edit-button-to-articles-pages","title":"Add an Edit button to articles' pages","text":"<p>We want to expose our new editing functionality in our templates.</p> <p>We will add a button for editing the article in <code>templates/article_meta.html</code>, based on the Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_ArticleMeta.svelte][_ArticleMeta.svelte]]:</p> <pre><code>&lt;div class=\"article-meta\"&gt;\n  &lt;div class=\"info\"&gt;\n    &lt;span class=\"author\"&gt;\n      {{ article.author.user.username }}\n    &lt;/span&gt;\n    &lt;span class=\"date\"&gt;\n      {{ article.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n  &lt;/div&gt;\n  &lt;span&gt;                                                            &lt;!-- new --&gt;\n    &lt;a                                                              &lt;!-- # --&gt;\n      href=\"{% url 'editor_update' slug_uuid=article.slug_uuid %}\"  &lt;!-- # --&gt;\n      class=\"btn btn-outline-secondary btn-sm\"                      &lt;!-- # --&gt;\n    &gt;                                                               &lt;!-- # --&gt;\n      &lt;span class=\"ion-edit\"&gt;                                       &lt;!-- # --&gt;\n        Edit Article                                                &lt;!-- # --&gt;\n      &lt;/span&gt;                                                       &lt;!-- # --&gt;\n    &lt;/a&gt;                                                            &lt;!-- # --&gt;\n  &lt;/span&gt;                                                           &lt;!-- # --&gt;\n&lt;/div&gt;\n</code></pre> <p>This is the first time that we pass parameters to a URL in a Django template.</p> <p>We only just added a <code>urlpattern</code> to <code>articles/urls.py</code>, and we know that it takes a <code>slug_uuid</code> as a parameter, so we pass <code>article.slug_uuid</code> as an argument to our URL, as explained in the docs for the <code>url</code> tag.</p>"},{"location":"05_creating_editing_and_deleting_articles/#adapt-get_object_or_404-method","title":"Adapt <code>get_object_or_404</code> method","text":"<p>Try navigating to an article: you should be able to view the Edit button. But try editing the thing and you'll just get an error:</p> <p>AttributeError at /editor/createview-50952832-f5b4-4f93-9edc-33aaa5f73565</p> <p>Generic detail view EditorUpdateView must be called with either an object pk or a slug in the URLconf.</p> <p>Request Method: GET Request URL: http://127.0.0.1:8000/editor/createview-50952832-f5b4-4f93-9edc-33aaa5f73565</p> <p>Well well well, pretty sure we have seen an error just like this before\u2026 The <code>UpdateView</code> must be called with an object <code>pk</code> or a <code>slug</code>, but we have this <code>slug_uuid</code> field instead.</p> <p>Since we've seen and solved this error when we were implementing <code>ArticleDetailView</code>, let's just go back and add the same code to <code>EditorUpdateView</code> in <code>articles/views.py</code>:</p> <pre><code># ...\nclass EditorUpdateView(UpdateView):\n    \"\"\"View for editing articles.\"\"\"\n\n    # ...\n\n    def get_object(self):                                       # new\n        slug_uuid = self.kwargs.get(\"slug_uuid\")                #\n        return get_object_or_404(Article, slug_uuid=slug_uuid)  #\n</code></pre> <p>We're just teaching our <code>EditorUpdateView</code> to retrieve the right <code>Article</code> instance based on a <code>slug_uuid</code> value.</p> <p>Try editing an article now: you get a nice form with prepopulated fields, and can even save any changes!</p>"},{"location":"05_creating_editing_and_deleting_articles/#deleting-articles","title":"Deleting articles","text":"<p>Our users can now create and edit articles: the only missing functionality is article deletion. Let's get to it.</p>"},{"location":"05_creating_editing_and_deleting_articles/#subclass-a-deleteview","title":"Subclass a <code>DeleteView</code>","text":"<p>In <code>views.py</code>, we create a <code>ArticleDeleteView</code>:</p> <pre><code># ...\nfrom django.views.generic import (\n    # ...\n    DeleteView,                                 # new\n)\n\n# ...\nclass EditorDeleteView(DeleteView):             # new\n    \"\"\"View for deleting articles.\"\"\"           #\n                                                #\n    model = Article                             #\n    template_name = \"article_detail.html\"       #\n    success_url = reverse_lazy(\"home\")          #\n</code></pre> <p>The <code>DeleteView</code> generic class-based view allows to delete an existing object.</p> <p>The user will delete an article from the article's page, so that page will also be removed, and the user needs to be redirected to another URL after deletion: we will redirect the user to the <code>home</code> URL with <code>reverse_lazy</code> URL resolver, which we need to use instead of <code>reverse</code> in class-based views.</p> <p>In a second, we'll explain why we're using <code>templates/article_detail.html</code> as the template for this view, and why it's interesting.</p>"},{"location":"05_creating_editing_and_deleting_articles/#add-a-urlpattern_2","title":"Add a <code>urlpattern</code>","text":"<p>First, let's create a <code>urlpattern</code> in <code>articles/urls.py</code>:</p> <pre><code># ...\nfrom .views import (\n    # ...\n    EditorDeleteView,                           # new\n)\n\nurlpatterns = [\n    # ...\n    path(                                       # new\n        \"editor/&lt;slug:slug_uuid&gt;/delete\",       #\n        EditorDeleteView.as_view(),             #\n        name=\"editor_delete\",                   #\n    ),                                          #\n]\n</code></pre>"},{"location":"05_creating_editing_and_deleting_articles/#create-a-template","title":"Create a template","text":"<p>The common way to implement a <code>DeleteView</code> is to have a GET form on some page (for example, the article's detail page) that redirects to a confirmation page with a POST form that will delete the object. GET forms are used to construct a URL based on the data from the form: a good example are search forms, which take the data (a query, like \u201cform\u201d) and send it to a URL (like \u201chttps://docs.djangoproject.com/search/?q=forms&amp;release=1\u201d). POST forms, which we've covered before, are used to modify data server-side.</p> <p>But that's not the workflow we want in the Realworld app: we should be able to delete an article straight from its detail page, which is why we specified <code>article_detail.html</code> template as our <code>template_name</code>. Implementing this will require some complicated code (relative to what we've written before), but we'll go through it slowly.</p> <p>First, we'll create <code>templates/article_delete.html</code>: this will hold the form for deleting the article.</p> <pre><code>&lt;form\n    method=\"POST\"\n    action=\"{% url 'editor_delete' slug_uuid=article.slug_uuid %}\"\n    style=\"display:inline\"\n&gt;\n  {% csrf_token %}\n  &lt;button\n      class=\"btn btn-outline-danger btn-sm\"\n      value=\"DELETE\"\n      onclick=\"return confirm('Are you sure you want to delete {{ article.title }}?')\"\n  &gt;\n    &lt;span class=\"ion-trash-a\"&gt;\n      Delete Article\n    &lt;/span&gt;\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>This is our POST form, the form that will delete the object identified by the parameter <code>slug_uuid</code> we're passing to the <code>editor_delete</code> URL. Since this is a POST form, it requires a <code>csrf_token</code> tag.</p> <p>Now, we want to load this template in <code>article_meta.html</code> directly, alongside the Edit button. We'll do this with an <code>include</code> tag:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;span&gt;\n  &lt;a\n    href=\"{% url 'editor_update' slug_uuid=article.slug_uuid %}\"\n    class=\"btn btn-outline-secondary btn-sm\"\n  &gt;\n    &lt;span class=\"ion-edit\"&gt;\n      Edit Article\n    &lt;/span&gt;\n  &lt;/a&gt;\n  {% include 'article_delete.html' %}               &lt;!-- new --&gt;\n&lt;/span&gt;\n&lt;!-- ... --&gt;\n</code></pre>"},{"location":"05_creating_editing_and_deleting_articles/#adapt-get_object_or_404-method_1","title":"Adapt <code>get_object_or_404</code> method","text":"<p>Before we try deleting an article, we remember that we need to teach our <code>ArticleDeleteView</code> to identify articles by their <code>slug_uuid</code>.</p> <p>In <code>articles/views.py</code>:</p> <pre><code># ...\nclass EditorDeleteView(DeleteView):\n    \"\"\"View for deleting articles.\"\"\"\n\n    # ...\n\n    def get_object(self):                                       # new\n        slug_uuid = self.kwargs.get(\"slug_uuid\")                #\n        return get_object_or_404(Article, slug_uuid=slug_uuid)  #\n</code></pre> <p>Try deleting an article: you should get a nice confirmation message while still on the <code>article_detail.html</code> template, before the article is deleted.</p>"},{"location":"06_comments/","title":"Comments","text":""},{"location":"06_comments/#introduction","title":"Introduction","text":"<p>Now that we have articles, we need comments. Gotta give our users a voice, right?</p>"},{"location":"06_comments/#model","title":"Model","text":"<p>Comments are a whole new object for our app, so we need to create a model.</p> <p>A comment will need a related article, an author, a body, and a date.</p> <p>Let's create a <code>Comment</code> model in <code>articles/models.py</code>:</p> <pre><code># ...\n\nclass Comment(models.Model):\n    article = models.ForeignKey(\n        Article,\n        on_delete=models.CASCADE,\n        related_name=\"comments\",\n        to_field=\"slug_uuid\",\n    )\n    body = models.TextField()\n    author = models.ForeignKey(\n        \"users.Profile\",\n        on_delete=models.CASCADE,\n        related_name=\"comments\",\n    )\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.body[:60] + \"...\"\n\n    def get_absolute_url(self):\n        return reverse(\"article_detail\", kwargs={\"slug_uuid\": self.article.slug_uuid})\n</code></pre> <p>We've been through this before, so we can be quick:</p> <ul> <li>Our <code>article</code> field is a many-to-one relationship that relates the <code>Comment</code> model to the <code>Article</code> model. By default, Django uses the <code>pk</code> of the related object, but we're working with <code>slug_uuid</code> fields in this tutorial, hence <code>to_field=\"slug_uuid\"</code>.</li> <li>The <code>author</code> is a many-to-one relationship that relates <code>Comment</code> to <code>Profile</code>.</li> <li>The string representation of our model (<code>__str__</code>) is the truncated comment body.</li> <li>The canonical URL for a <code>Comment</code> instance is the same as the URL for the <code>Article</code> instance attached to the comment: we don't need to navigate to specific comments in Conduit, so we might as well have a simplified <code>get_absolute_url</code>.</li> </ul> <p>Time to <code>makemigrations</code> and <code>migrate</code>. You should get the following error:</p> <p>SystemCheckError: System check identified some issues:</p> <p>ERRORS: articles.Comment.article: (fields.E311) \u2018Article.slug_uuid\u2019 must be unique because it is referenced by a foreign key. HINT: Add unique=True to this field or add a UniqueConstraint (without condition) in the model Meta.constraints.</p> <p>That's because we're using articles' <code>slug_uuid</code> fields as ForeignKeys for the comments (so that we can filter our comments by the attached articles' <code>slug_uuid</code> fields instead of their UUIDs). As the error message indicates, this error is easily corrected by adding <code>unique=True</code> as an argument to the <code>slug_uuid</code> field in the <code>Article</code> model in <code>articles/models.py</code>.</p> <pre><code># ...\n\nclass Article(models.Model):\n    # ...\n    # slug_uuid = models.SlugField(max_length=100, editable=False)                  # from this\n    slug_uuid = models.SlugField(max_length=100, editable=False, unique=True)       # to this\n    # ...\n</code></pre> <p>You should be able to <code>makemigrations</code> and <code>migrate</code> after that.</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# Migrations for 'articles':\n#   conduit/articles/migrations/0004_alter_article_slug_uuid_comment.py\n#     - Alter field slug_uuid on article\n#     - Create model Comment\n(django) django_tutorial$ python manage.py migrate\n# Operations to perform:\n#   Apply all migrations: admin, articles, auth, contenttypes, sessions, users\n# Running migrations:\n#   Applying articles.0004_alter_article_slug_uuid_comment... OK\n</code></pre> <p>Now, we need to register our model in <code>articles/admin.py</code>, so that we can access that object in the Django admin:</p> <pre><code>from django.contrib import admin\nfrom .models import Article, Comment        # new\n\nadmin.site.register(Article)\nadmin.site.register(Comment)                # new\n</code></pre>"},{"location":"06_comments/#viewing-comments","title":"Viewing comments","text":"<p>In order to view comments, we need to have some comments to view first: go to the Django admin and create a few comments for a couple articles by hand.</p> <p>We want to be able to view the comments on each article's detail page. Consequently, we need to modify <code>templates/article_detail.html</code> (based on Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/%5Bslug%5D/index.svelte][article/[slug]/index.svelte]]):</p> <pre><code>&lt;!-- ... --&gt;\n&lt;div class=\"container page\"&gt;\n  &lt;div class=\"row article-content\"&gt;\n    &lt;div class=\"col-xs-12\"&gt;\n      &lt;div&gt;\n        {{ article.body|linebreaks }}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;hr /&gt;                                    &lt;!-- new --&gt;\n  &lt;div class=\"row\"&gt;                         &lt;!-- new --&gt;\n    {% include \"comment_container.html\" %}  &lt;!-- new --&gt;\n  &lt;/div&gt;                                    &lt;!-- new --&gt;\n&lt;/div&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>Now create <code>templates/comment_container.html</code> and add the following (based on Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_CommentContainer.svelte][_CommentContainer.svelte]]):</p> <pre><code>&lt;div class=\"col-xs-12 col-md-8 offset-md-2\"&gt;\n  {% for comment in article.comments.all|dictsortreversed:'created_at' %}\n    {% include \"comment.html\" %}\n  {% endfor %}\n&lt;/div&gt;\n</code></pre> <p>We want to view all the comments for the article we're viewing, from most to least recent (which we achieve with the <code>dictsortreversed</code> template filter).</p> <p>We will implement the rendering logic for our comments in <code>templates/comment.html</code> (based on Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_Comment.svelte][_Comment.svelte]]):</p> <pre><code>&lt;div class=\"card\"&gt;\n  &lt;div class=\"card-block\"&gt;\n    &lt;p class=\"card-text\"&gt;\n      {{ comment.body }}\n    &lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=\"card-footer\"&gt;\n    &lt;span class=\"comment-author\"&gt;\n      {{ comment.author.user.username }}\n    &lt;/span&gt;\n    &lt;span class=\"date-posted\"&gt;\n      {{ comment.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Nothing new here: this template displays the comment's body, author's username, and creation date.</p> <p>Try navigating to one of the articles that you created comments for through the Django admin: you should see them displayed under the article (though they made do with some decoration, which we will get to later).</p>"},{"location":"06_comments/#creating-comments","title":"Creating comments","text":"<p>We will now start allowing our users to leave comments on the website.</p> <p>We could do this like in the Django Girls tutorial: the <code>ArticleDetailView</code> would include a button that would direct to <code>CommentCreateView</code> on a separate page, and saving the comment would bring the user back to the <code>ArticleDetailView</code>. However, the <code>RealWorldApp</code> allows users to create and save their comments directly below the article, on the same page, so that's what we're going to try.</p> <p>Surprisingly, this is not straightforward to implement in Django, because it implies mixing <code>DetailView</code> and <code>CreateView</code> functionalities in a single page, which is made difficult by the fact that the <code>DetailView</code> doesn't have a POST method, while the <code>CreateView</code> requires it.</p>"},{"location":"06_comments/#create-commentcreateview","title":"Create <code>CommentCreateView</code>","text":"<p>Fortunately, our use case is covered in the Django documentation, which greatly simplifies the task at hand.</p> <p>First, we'll create a <code>CommentCreateView</code> in <code>users/views.py</code>:</p> <pre><code># ...\nfrom django.urls import reverse_lazy, reverse\nfrom .models import Article, Comment\n\n# ...\nclass CommentCreateView(CreateView):\n    \"\"\"View for creating comments.\"\"\"\n\n    model = Comment\n    fields = [\"body\"]\n    template_name = \"article_detail.html\"\n\n    def form_valid(self, form):\n        form.instance.author = self.request.user.profile\n        form.instance.article = Article.objects.filter(\n            slug_uuid=self.kwargs.get(\"slug_uuid\")\n        ).first()\n        return super().form_valid(form)\n\n    def get_success_url(self):\n        return reverse(\n            \"article_detail\", kwargs={\"slug_uuid\": self.object.article.slug_uuid}\n        )\n</code></pre> <p>We have seen a lot of this before, but a lot is new:</p> <ul> <li>We subclass a <code>CreateView</code> and specify the object this view will be related to (<code>Comment</code>), which fields we want to be able to modify when we create <code>Comment</code> instances (we only want to modify the comment body), and which template our view is going to be using.</li> <li>We override the <code>form_valid</code> method because we need to specify the <code>author</code> (the currently logged-in user) and <code>article</code> (the article that the comment is being attached to) fields required by the <code>Comment</code> model.</li> <li>We also override the <code>get_success_url</code> because we want the user to be redirected to the <code>ArticleDetailView</code> upon saving the comment (we need to import the <code>reverse</code> URL resolver for that).</li> </ul>"},{"location":"06_comments/#adapt-articledetailview","title":"Adapt <code>ArticleDetailView</code>","text":"<p>Now, we need to modify the <code>ArticleDetailView</code> to make the <code>CommentCreateView</code>'s form available to <code>templates/article_detail.html</code> through the <code>get_context_data</code> method:</p> <pre><code># ...\n\nclass ArticleDetailView(DetailView):\n    \"\"\"Detail view for individual articles.\"\"\"\n\n    # ...\n\n    def get_context_data(self, **kwargs):                       # new\n        context = super().get_context_data(**kwargs)            # new\n        context[\"form\"] = CommentCreateView().get_form_class()  # new\n        return context                                          # new\n</code></pre> <p>Let's explain our override of <code>get_context_data</code>:</p> <ul> <li>the <code>get_context_data</code> method populates the dictionary that will be used as the template context</li> <li><code>super().get_context_data(**kwargs)</code> is boilerplate that populates our <code>context</code> with the data the view would come with by default</li> <li>we then pass the newly created <code>CommentCreateView</code>'s form (which we get through its <code>get_form_class</code> method) to the <code>ArticleDetailView</code>'s <code>context</code> (<code>DetailView</code> generic views do not have a <code>form</code>, so we're not overwriting anything here)</li> <li>we now have access to the relevant context of both our views.</li> </ul>"},{"location":"06_comments/#combine-articledetailview-and-commentcreateview","title":"Combine <code>ArticleDetailView</code> and <code>CommentCreateView</code>","text":"<p>Finally, we create a view that combines <code>ArticleDetailView</code> and <code>CommentCreateView</code>:</p> <pre><code># ...\nfrom django.views.generic import (\n    # ...\n    View,\n)\n\n\n# ...\nclass ArticleCommentView(View):\n    \"\"\"View for viewing articles and posting comments.\"\"\"\n\n    def get(self, request, *args, **kwargs):\n        view = ArticleDetailView.as_view()\n        return view(request, *args, **kwargs)\n\n    def post(self, request, *args, **kwargs):\n        view = CommentCreateView.as_view()\n        return view(request, *args, **kwargs)\n</code></pre> <p>We now have a new hybrid view that, depending on whether the method is <code>GET</code> or <code>POST</code>, will return the <code>ArticleDetailView</code> or the <code>CommentCreateView</code>, respectively.</p>"},{"location":"06_comments/#adapt-the-urlpattern","title":"Adapt the <code>urlpattern</code>","text":"<p>In order for our new hybrid view to be able to act as intended, we need to specify it as the view that deals with requests to the <code>article/&lt;slug:slug_uuid&gt;</code> path in <code>articles/urls.py</code>:</p> <pre><code># ...\nfrom .views import (\n    # ...\n    # ArticleDetailView,                                                                    # from this\n    ArticleCommentView,                                                                     # to this\n)\n\nurlpatterns = [\n    # ...\n    path(\n        # \"article/&lt;slug:slug_uuid&gt;\", ArticleDetailView.as_view(), name=\"article_detail\"    # from this\n        \"article/&lt;slug:slug_uuid&gt;\", ArticleCommentView.as_view(), name=\"article_detail\"     # to this\n    ),\n]\n</code></pre>"},{"location":"06_comments/#create-a-template","title":"Create a template","text":"<p>Now that <code>articles/views.py</code> and <code>articles/urls.py</code> are ready, we need to create the templates.</p> <p>Create <code>comment_input.html</code> (based on Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_CommentInput.svelte][_CommentInput.svelte]]):</p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'article_detail' slug_uuid=object.slug_uuid %}\"\n    class=\"card comment-form\"\n&gt;\n  {% csrf_token %}\n  &lt;div class=\"card-block\"&gt;\n    &lt;textarea\n        class=\"form-control\"\n        rows=\"3\"\n        placeholder=\"Write a comment...\"\n        name=\"{{ form.body.name }}\"\n    &gt;{{ form.body.value|default_if_none:'' }}&lt;/textarea&gt;\n  &lt;/div&gt;\n  &lt;div class=\"card-footer\"&gt;\n    &lt;button class=\"btn btn-sm btn-primary\" type=\"submit\"&gt;\n      Post Comment\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <p>This POST form corresponds to <code>CommentCreateView</code>'s form: when we send submit this form in our app, the <code>ArticleCommentView</code> will return the <code>CommentCreateView</code>, which will process the request and create the requested <code>Comment</code> instance.</p> <p>In <code>templates/comment_container.html</code>, we include the <code>comment_input.html</code> template:</p> <pre><code>&lt;div class=\"col-xs-12 col-md-8 offset-md-2\"&gt;\n  &lt;div&gt;                                                             &lt;!-- new --&gt;\n    {% include \"comment_input.html\" %}                              &lt;!-- # --&gt;\n  &lt;/div&gt;                                                            &lt;!-- # --&gt;\n  {% for comment in article.comments.all|dictsortreversed:'created_at' %}\n&lt;!-- ... --&gt;\n</code></pre> <p>Everything should be working now. Try to create some comments on an article.</p>"},{"location":"06_comments/#deleting-comments","title":"Deleting comments","text":"<p>We now want to be able to delete comments.</p> <p>In <code>articles/views.py</code>, add <code>CommentDeleteView</code>:</p> <pre><code># ...\n\nclass CommentDeleteView(DeleteView):\n    \"\"\"View for deleting comments.\"\"\"\n\n    model = Comment\n    template_name = \"article_detail.html\"\n\n    def get_success_url(self):\n        return reverse(\"article_detail\", kwargs={\"slug_uuid\": self.object.article.slug_uuid})\n</code></pre> <p>In <code>articles/urls.py</code>, we add a <code>urlpattern</code>:</p> <pre><code>urlpatterns = [\n    # ...\n    path(\n        \"article/&lt;slug:slug_uuid&gt;/comment/&lt;int:pk&gt;/delete\",\n        CommentDeleteView.as_view(),\n        name=\"comment_delete\",\n    ),\n]\n</code></pre> <p>We require <code>pk</code> as an argument because <code>CommentDeleteView</code> needs this information to identify the comment to delete. The <code>&lt;slug:slug_uuid&gt;</code> part is unnecessary, but it makes the path more logical, I find.</p> <p>Create <code>templates/comment_delete.html</code> (based on Svelte implementation's [[https://github.com/sveltejs/realworld/blob/master/src/routes/article/\\slug\\/_Comment.svelte][_Comment.svelte]]):</p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'comment_delete' slug_uuid=article.slug_uuid pk=comment.pk %}\"\n    class=\"mod-options\"\n&gt;\n  {% csrf_token %}\n  &lt;button\n      style=\"background: none;\n             border: none;\n             padding: 0;\n             margin: 0;\n             font-size: inherit;\n             margin-left: 5px;\n             opacity: 0.6;\n             cursor: pointer;\"\n      value=\"DELETE\"\n      class=\"ion-trash-a\"\n  &gt;&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>In <code>templates/comment.html</code>:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;div class=\"card-footer\"&gt;\n  &lt;span class=\"comment-author\"&gt;\n    {{ comment.author }}\n  &lt;/span&gt;\n  &lt;span class=\"date-posted\"&gt;\n    {{ comment.created_at|date:\"D M d Y\" }}\n  &lt;/span&gt;\n  {% include 'comment_delete.html' %}             &lt;!-- new --&gt;\n&lt;/div&gt;\n&lt;!-- ... --&gt;\n</code></pre>"},{"location":"07_users_and_profiles/","title":"Users and Profiles","text":""},{"location":"07_users_and_profiles/#introduction","title":"Introduction","text":"<p>Time to work on our users and profiles.</p> <p>The Django docs say \u201cit may be more suitable to store app-specific user information in a model that has a relation with your custom user model. That allows each app to specify its own user data requirements without potentially conflicting or breaking assumptions by other apps. It also means that you would keep your user model as simple as possible, focused on authentication, and following the minimum requirements Django expects custom user models to meet.\u201d.</p> <p>This is why we'll have the authentication logic in a <code>User</code> model and the profile logic in a <code>Profile</code> model.</p>"},{"location":"07_users_and_profiles/#user-model","title":"User model","text":""},{"location":"07_users_and_profiles/#creating-the-user-model","title":"Creating the User model","text":"<p>The <code>User</code> model will contain everything related to authentication.</p> <p>We need an email, a username, and a password. Let's add the following to the <code>User</code> model in <code>users/models.py</code>:</p> <pre><code>from django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\n\nclass User(AbstractUser):\n    \"\"\"User model\"\"\"\n\n    username = models.CharField(max_length=255, unique=True)\n    email = models.EmailField(unique=True)\n\n    USERNAME_FIELD = \"email\"\n    REQUIRED_FIELDS = [\"username\"]\n\n    def __str__(self):\n        self.email\n</code></pre> <p>The <code>username</code> field is the unique human-readable identifier that we can represent users with in our app. The <code>email</code> field holds the email users will be logging in with. We specify this in <code>USERNAME_FIELD</code>. The <code>password</code> field is already provided by <code>AbstractUser</code>. <code>REQUIRED_FIELDS</code> is the list of field users will be prompted for at sign up: because the <code>USERNAME_FIELD</code> and the <code>password</code> are already required by Django, we only need to specify <code>username</code>. More information about the fields can be found in the docs for the default Django User model.</p>"},{"location":"07_users_and_profiles/#creating-the-usermanager","title":"Creating the UserManager","text":"<p>We also need a <code>UserManager</code>, as advised by the docs. In <code>models.py</code>, we add the following (make sure to place the class definition BEFORE the class definition for the <code>User</code> model):</p> <pre><code># ...\nfrom django.contrib.auth.models import AbstractUser, UserManager\n\n# ...\nclass CustomUserManager(UserManager):\n    \"\"\"custom UserManager with unique identifier is email instead of username\"\"\"\n\n    def create_user(self, username, email, password=None):\n        \"\"\"Create and return a User with username, email, and password\"\"\"\n\n        if email is None:\n            raise ValueError(\"Email is required.\")\n        if username is None:\n            raise ValueError(\"Username is required\")\n\n        email = self.normalize_email(email)\n        user = self.model(username=username, email=email)\n        user.set_password(password)\n        user.save()\n\n        return user\n\n    def create_superuser(self, username, email, password=None):\n        \"\"\"Create and return a SuperUser with admin permissions.\"\"\"\n\n        user = self.create_user(username, email, password)\n        user.is_staff = True\n        user.is_superuser = True\n        user.is_active = True\n        user.save()\n\n        return user\n</code></pre> <p><code>create_user</code> and <code>create_superuser</code> are self-explanatory.</p> <p>We now need to go back to the <code>User</code> model in <code>users/models.py</code> and indicate to Django that the <code>UserManager</code> defined above will manage objects of type <code>User</code>:</p> <pre><code># ...\nclass User(AbstractUser):\n    \"\"\"User model\"\"\"\n\n    username = models.CharField(max_length=255, unique=True)\n    email = models.EmailField(unique=True)\n\n    USERNAME_FIELD = \"email\"\n    REQUIRED_FIELDS = [\"username\"]\n\n    objects = CustomUserManager()               # new\n\n    def __str__(self):\n        return self.email\n</code></pre> <p>Make sure to <code>makemigrations</code> and <code>migrate</code>, so that Django is aware of your new model.</p>"},{"location":"07_users_and_profiles/#registering-our-new-model","title":"Registering our new model","text":"<p>We need to register this new <code>User</code> model in <code>users/admins.py</code>, to have access to it in our admin app.</p> <pre><code>from django.contrib import admin\nfrom .models import User\n\nadmin.site.register(User)\n</code></pre>"},{"location":"07_users_and_profiles/#profile-model","title":"Profile model","text":""},{"location":"07_users_and_profiles/#creating-the-profile-model","title":"Creating the Profile model","text":"<p>We are following the instructions in the Django docs about extending a User model. We need to store some information about our users in the database. Each <code>User</code> object should be related to a single <code>Profile</code>, and vice-versa: we'll use a <code>OneToOneField</code> relationship.</p> <p>Our <code>Profile</code> needs the following fields:</p> <ul> <li>image</li> <li>bio</li> <li>articles</li> <li>comments</li> </ul> <p>We have already taken care of the two last fields in the <code>Article</code> and <code>Comment</code> models through the <code>ForeignKey</code> relationships.</p> <p>We will allow users to specify a URL to their avatar and to write a short bio. This is optional, so we make sure to have <code>blank=True</code>. Let's add the following to the <code>Profile</code> model in <code>users/models.py</code>:</p> <pre><code>class Profile(models.Model):\n    \"\"\"Profile model\"\"\"\n\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    image = models.URLField(\n        default=\"https://static.productionready.io/images/smiley-cyrus.jpg\"\n    )\n    bio = models.TextField(max_length=1000, blank=True)\n\n    def __str__(self):\n        return self.user.username\n</code></pre> <p>As always, whenever you change a model, you should <code>makemigrations</code> and <code>migrate</code>.</p>"},{"location":"07_users_and_profiles/#automating-the-creation-of-profiles-for-each-new-user","title":"Automating the creation of profiles for each new user","text":"<p>Since we're defining the <code>Profile</code> outside of the <code>User</code> model, a profile won't be created automatically whenever a user signs up.</p> <p>What we want is to be notified when a new User instance is created (generally at sign-up), so that we can create a Profile model. To achieve this, we need to use signals.</p> <p>Django already takes care of sending the signal for new User instances, so we only need to define a receiver function. We want to be notified after a new instance is saved, so we'll use the post_save signal.</p> <p>Create a <code>signals.py</code> file in the <code>users</code> folder and add the following:</p> <pre><code>from django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django.contrib.auth import get_user_model\nfrom .models import Profile\n\n\n@receiver(post_save, sender=get_user_model())\ndef create_profile_for_user(sender, instance, created, **kwargs):\n    if created:\n        Profile.objects.create(user=instance)\n\n\n@receiver(post_save, sender=get_user_model())\ndef save_profile_for_user(sender, instance, **kwargs):\n    instance.profile.save()\n</code></pre> <p>In order to activate this signal, we will modify <code>users/apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\n\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"conduit.users\"\n\n    def ready(self):                        # new\n        import conduit.users.signals        # new\n</code></pre> <p>This signal runs whenever a <code>User</code> is saved. By checking for <code>created</code>, we make sure to only initiate a <code>Profile</code> for the <code>User</code> instance if the User has just been created, instead of whenever the instance is updated.</p>"},{"location":"07_users_and_profiles/#registering-our-new-model_1","title":"Registering our new model","text":"<p>We need to register this new <code>Profile</code> model in <code>users/admins.py</code>, to have access to it in our admin app, but we want to be able to view <code>User</code> and <code>Profile</code> information for a given user in the same place.</p> <p>For this, we subclass a StackedInline class and define a custom <code>ModelAdmin</code>:</p> <pre><code>from django.contrib import admin\nfrom .models import User, Profile\n\n\nclass ProfileInline(admin.StackedInline):\n    model = Profile\n    can_delete = False\n\n\nclass UserAdmin(admin.ModelAdmin):\n    inlines = [ProfileInline]\n\n\nadmin.site.register(User, UserAdmin)\n</code></pre> <p>You'll notice that this code is much shorter than what the docs say: we're trying to keep it simple, so we'll do without some of the quality of life improvements that a more intricate code would allow.</p> <p>When you go to Django admin, the <code>User</code> model fields will seem out of order: this is because the <code>AbstractUser</code> fields will be shown before the fields explicitly defined in the <code>User</code> model, but you can order them by adding a ModelAdmin.fields option.</p>"},{"location":"08_authentication_i_login_logout_signup/","title":"Authentication I: Login, Logout, Signup","text":""},{"location":"08_authentication_i_login_logout_signup/#introduction","title":"Introduction","text":"<p>Here comes authentication. Because it is a bit complicated, authentication will take two chapters: one for implementing the login, logout, and signup processes, and one for shifting our entire app behind these authentication requirements.</p>"},{"location":"08_authentication_i_login_logout_signup/#auth-views","title":"Auth views","text":"<p>In <code>users/views.py</code>, we take advantage of the generic <code>LoginView</code>, <code>LogoutView</code>, and <code>CreateView</code> to implement our authentication logic:</p> <pre><code>from django.contrib.auth.views import LoginView, LogoutView\nfrom django.views.generic import CreateView\nfrom django.urls import reverse_lazy\nfrom django.contrib.auth import get_user_model\n\n\nclass Login(LoginView):\n    template_name = \"login.html\"\n    next_page = reverse_lazy(\"home\")\n\n    def get(self, request, *args, **kwargs):\n        if request.user.is_authenticated:\n            return redirect(self.next_page)\n        return super().get(request, *args, **kwargs)\n\n\nclass Logout(LogoutView):\n    next_page = reverse_lazy(\"home\")\n\n\nclass SignUpView(CreateView):\n    model = get_user_model()\n    fields = [\"username\", \"email\", \"password\"]\n    template_name = \"signup.html\"\n    success_url = reverse_lazy(\"home\")\n\n    def get(self, request, *args, **kwargs):\n        if request.user.is_authenticated:\n            return redirect(self.success_url)\n        return super().get(request, *args, **kwargs)\n</code></pre> <p>We don't have to specify much to the generic views, they're quite full-featured as is. What we did here is indicate where the templates live and where the views redirect to (the defaults are <code>accounts/profile</code> for <code>LoginView</code> and <code>None</code> for <code>LogoutView</code>). We also overrode the <code>get</code> method in <code>LoginView</code> and <code>SignUpView</code>, so that already authenticated users who for some reason visit the login page are automatically redirected to the <code>home</code> URL. We didn't specify a template for <code>LogoutView</code> because it's not necessary.</p>"},{"location":"08_authentication_i_login_logout_signup/#auth-urls","title":"Auth urls","text":"<p>Let's deal with the URL patterns now. Create <code>users/urls.py</code> and add the following:</p> <pre><code>from django.urls import path\nfrom .views import Login, Logout, SignUp\n\n\nurlpatterns = [\n    path(\"login\", Login.as_view(), name=\"login\"),\n    path(\"logout\", Logout.as_view(), name=\"logout\"),\n    path(\"signup\", SignUp.as_view(), name=\"signup\"),\n]\n</code></pre> <p>For every app that we create, we need to tell <code>config/urls.py</code> to look at the patterns specified in the app's <code>urls.py</code> file:</p> <pre><code>urlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"\", include(\"conduit.articles.urls\")),\n    path(\"\", include(\"conduit.users.urls\")),        # new\n]\n</code></pre>"},{"location":"08_authentication_i_login_logout_signup/#auth-templates","title":"Auth templates","text":""},{"location":"08_authentication_i_login_logout_signup/#loginhtml","title":"login.html","text":"<p>Let's create <code>login.html</code> in the <code>templates</code> folder:</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n    &lt;title&gt;Sign in - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n    &lt;div class=\"auth-page\"&gt;\n        &lt;div class=\"container page\"&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;div class=\"col-md-6 offset-md-3 col-xs-12\"&gt;\n                    &lt;h1 class=\"text-xs-center\"&gt;Sign In&lt;/h1&gt;\n                    &lt;p class=\"text-xs-center\"&gt;\n                        &lt;a href=\"{% url 'signup' %}\"&gt;Need an account?&lt;/a&gt;\n                    &lt;/p&gt;\n                    {{ form.non_field_errors }}\n                    &lt;form method=\"post\"&gt;\n                        {% csrf_token %}\n                        &lt;fieldset class=\"form-group\"&gt;\n                            &lt;input\n                                class=\"form-control form-control-lg\"\n                                type=\"email\"\n                                placeholder=\"Email\"\n                                name=\"{{ form.username.name }}\"\n                            &gt;\n                            {{ form.username.errors }}\n                        &lt;/fieldset&gt;\n                        &lt;fieldset class=\"form-group\"&gt;\n                            &lt;input\n                                class=\"form-control form-control-lg\"\n                                type=\"password\"\n                                placeholder=\"Password\"\n                                name=\"{{ form.password.name }}\"\n                            &gt;\n                            {{ form.password.errors }}\n                        &lt;/fieldset&gt;\n                        &lt;button class=\"btn btn-lg btn-primary pull-xs-right\" type=\"submit\"&gt;\n                            Sign in\n                        &lt;/button&gt;\n                    &lt;/form&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>Notice that we are using <code>form.username</code> to authenticate. I initially was trying to work with <code>form.email</code>, because that was the field we chose to authenticate with, but it kept throwing errors: Django didn't see the field, didn't POST the value that I gave it, and asked for the username every time. It took me a while, but I realised that our username is the email. <code>form.username</code> is effectively querying what the <code>USERNAME_FIELD</code> is. Not straightforward though.</p>"},{"location":"08_authentication_i_login_logout_signup/#signuphtml","title":"signup.html","text":"<p>Create <code>signup.html</code>:</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n    &lt;title&gt;Sign up - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n    &lt;div class=\"auth-page\"&gt;\n        &lt;div class=\"container page\"&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;div class=\"col-md-6 offset-md-3 col-xs-12\"&gt;\n                    &lt;h1 class=\"text-xs-center\"&gt;Sign up&lt;/h1&gt;\n                    &lt;p class=\"text-xs-center\"&gt;\n                        &lt;a href=\"{% url 'login' %}\"&gt;Have an account?&lt;/a&gt;\n                    &lt;/p&gt;\n                    {{ form.non_field_errors }}\n                    &lt;form method=\"post\"&gt;\n                        {% csrf_token %}\n                        &lt;fieldset class=\"form-group\"&gt;\n                            &lt;input\n                                class=\"form-control form-control-lg\"\n                                type=\"text\"\n                                placeholder=\"Your {{ form.username.name }}\"\n                                name=\"{{ form.username.name }}\"\n                                value=\"{{ form.username.value|default_if_none:'' }}\"\n                            &gt;\n                        &lt;/fieldset&gt;\n                        {{ form.username.errors }}\n                        &lt;fieldset class=\"form-group\"&gt;\n                            &lt;input\n                                class=\"form-control form-control-lg\"\n                                type=\"email\"\n                                placeholder=\"Your {{ form.email.name }}\"\n                                name=\"{{ form.email.name }}\"\n                                value=\"{{ form.email.value|default_if_none:''  }}\"\n                            &gt;\n                        &lt;/fieldset&gt;\n                        {{ form.email.errors }}\n                        &lt;fieldset class=\"form-group\"&gt;\n                            &lt;input\n                                class=\"form-control form-control-lg\"\n                                type=\"password\"\n                                placeholder=\"Your {{ form.password.name }}\"\n                                name=\"{{ form.password.name }}\"\n                            &gt;\n                        &lt;/fieldset&gt;\n                        {{ form.password.errors }}\n                        &lt;button class=\"btn btn-lg btn-primary pull-xs-right\"&gt;\n                            Sign up\n                        &lt;/button&gt;\n                    &lt;/form&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n{% endblock %}\n</code></pre>"},{"location":"09_authentication_ii_securing_the_app/","title":"Authentication II: Securing the app","text":""},{"location":"09_authentication_ii_securing_the_app/#introduction","title":"Introduction","text":"<p>This is the second part of our authentication setup: we'll make sure that some actions in the app (creating posts, posting comments, etc.) are only accessible to authenticated users, while others are only accessible to a subset of authenticated users (only the authors of an article should be able to edit it, for example).</p>"},{"location":"09_authentication_ii_securing_the_app/#nav","title":"Nav","text":"<p>We don't want to expose the <code>New post</code> link to unauthenticated users.</p> <p>In <code>nav.html</code>:</p> <pre><code>&lt;nav class=\"navbar navbar-light\"&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;a rel=\"prefetch\" class=\"navbar-brand\" href=\"/\"&gt;conduit&lt;/a&gt;\n    &lt;ul class=\"nav navbar-nav pull-xs-right\"&gt;\n      &lt;li class=\"nav-item\"&gt;\n        {% url 'home' as home %}\n        &lt;a\n          href=\"{{ home }}\"\n          rel=\"prefetch\"\n          class=\"nav-link\n                 {% if request.path == home %}active{% endif %}\"\n        &gt;\n          Home\n        &lt;/a&gt;\n      &lt;/li&gt;\n      {% if user.is_authenticated %}                          &lt;!-- new from here --&gt;\n        &lt;li class=\"nav-item\"&gt;\n          {% url 'editor_create' as editor_create %}\n          &lt;a\n            href=\"{{ editor_create }}\"\n            rel=\"prefetch\"\n            class=\"nav-link\n                   {% if request.path == editor_create %}active{% endif %}\"\n          &gt;\n            &lt;span class=\"ion-compose\"&gt; New Post &lt;/span&gt;\n          &lt;/a&gt;\n        &lt;/li&gt;\n        &lt;li class=\"nav-item\"&gt;\n          &lt;a href=\"{% url 'logout' %}\" rel=\"prefetch\" class=\"nav-link\"&gt;\n            &lt;span class=\"ion-log-out\"&gt;&lt;/span&gt;\n          &lt;/a&gt;\n        &lt;/li&gt;\n      {% else %}\n        &lt;li class=\"nav-item\"&gt;\n          {% url 'login' as login %}\n          &lt;a\n            href=\"{{ login }}\"\n            rel=\"prefetch\"\n            class=\"nav-link\n                   {% if request.path == login %}active{% endif %}\"\n          &gt;\n            Sign in\n          &lt;/a&gt;\n        &lt;/li&gt;\n        &lt;li class=\"nav-item\"&gt;\n          {% url 'signup' as signup %}\n          &lt;a\n            href=\"{{ signup }}\"\n            rel=\"prefetch\"\n            class=\"nav-link\n                   {% if request.path == signup %}active{% endif %}\"\n          &gt;\n            Sign up\n          &lt;/a&gt;\n        &lt;/li&gt;\n      {% endif %}                                             &lt;!-- to here --&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/nav&gt;\n</code></pre>"},{"location":"09_authentication_ii_securing_the_app/#loginrequiredmixin","title":"LoginRequiredMixin","text":"<p>Some pages should only be accessible to authenticated users, and Django provides an easy way of doing so through mixins. Mixins are components that provide common extra functionality. They can be added to class-based views on the fly.</p> <p>In <code>articles/views.py</code>, add the following:</p> <pre><code># ...\nfrom django.contrib.auth.mixins import LoginRequiredMixin\n\nclass EditorCreateView(LoginRequiredMixin, CreateView):\n    # ...\nclass EditorDeleteView(LoginRequiredMixin, DeleteView):\n    # ...\nclass CommentCreateView(LoginRequiredMixin, CreateView):\n    # ...\nclass ArticleCommentView(LoginRequiredMixin, View):\n    # ...\nclass CommentDeleteView(LoginRequiredMixin, DeleteView):\n    # ...\n</code></pre> <p>Notice that the <code>LoginRequiredMixin</code> should be at the leftmost position in the inheritance list: don't write <code>class EditorDeleteView(DeleteView, LoginRequiredMixin)</code> if you want to avoid errors.</p> <p>If you try creating a post from the app, you should get this error:</p> Login error <p>The cause of the problem is given in the line:</p> <p>The current path, accounts/login/, didn't match any of these.</p> <p>By default, the login url in Django is <code>accounts/login</code>: while we changed our urls everywhere, the <code>LoginRequiredMixin</code> does not know that. To fix this, we need to add this line in <code>config/settings.py</code>:</p> <pre><code>LOGIN_URL = \"login\"\n</code></pre>"},{"location":"09_authentication_ii_securing_the_app/#only-allow-authors-to-edit-or-delete-their-articles-and-comments","title":"Only allow authors to edit or delete their articles and comments","text":"<p>While we're at it, let's also make sure that articles and comments can only be edited and deleted by their authors.</p> <p>In <code>templates/article_detail.html</code>, we hide the button for editing and deleting articles from any user who is not the article's author:</p> <pre><code>&lt;!-- ... --&gt;\n{% if user == article.author.user %}                        &lt;!-- new --&gt;\n  &lt;span&gt;\n    &lt;a\n      href=\"{% url 'editor_update' slug_uuid=article.slug_uuid %}\"\n      class=\"btn btn-outline-secondary btn-sm\"\n    &gt;\n      &lt;span class=\"ion-edit\"&gt;\n        Edit Article\n      &lt;/span&gt;\n    &lt;/a&gt;\n    {% include 'article_delete.html' %}\n  &lt;/span&gt;\n{% endif %}                                                 &lt;!-- new --&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>In <code>templates/comment_container.html</code>:</p> <pre><code>&lt;!-- ... --&gt;\n{% if user == comment.author.user %}    &lt;!-- new --&gt;\n  {% include 'comment_delete.html' %}\n{% endif %}                             &lt;!-- new --&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>In <code>users/views.py</code>, we make sure that editing or deleting actions are only taken into account if the user is the author of the article or comment:</p> <pre><code># ...\nfrom django.shortcuts import redirect\n\n# ...\nclass EditorUpdateView(LoginRequiredMixin, UpdateView):\n    # ...\n    def post(self, request, *args, **kwargs):\n        if request.user == self.get_object().author.user:\n            return super().post(request, *args, **kwargs)\n        return redirect(self.get_object().get_absolute_url())\n\n\nclass EditorDeleteView(LoginRequiredMixin, DeleteView):\n    # ...\n    def post(self, request, *args, **kwargs):\n        if request.user == self.get_object().author.user:\n            return super().post(request, *args, **kwargs)\n        return redirect(self.get_object().get_absolute_url())\n\n\nclass CommentDeleteView(LoginRequiredMixin, DeleteView):\n    # ...\n    def post(self, request, *args, **kwargs):\n        if request.user == self.get_object().author.user:\n            return super().post(request, *args, **kwargs)\n        return redirect(self.get_object().get_absolute_url())\n</code></pre>"},{"location":"09_authentication_ii_securing_the_app/#testing-signup-and-login","title":"Testing signup and login","text":"<p>For now, we only have one user for our app: the <code>admin</code> superuser.</p> <p>Let's create a new user by clicking on <code>Sign up</code> in our navbar. Enter a username, an email (which doesn't have to be a real one as long as it's the right format), and a password.</p> <p>When you finalise this action by clicking the button <code>Sign up</code>, you'll notice that you're redirected to the homepage without being logged in. This is fine - you can sign in manually as the user you just created or you might want to implement an email verification before allowing sign ups - but, in our case, we might as well sign in the user automatically.</p> <p>In <code>users/views.py</code>, add the following to <code>SignUpView</code> (as explained in this StackOverflow answer):</p> <pre><code># ...\nfrom django.shortcuts import redirect  # new\nfrom django.contrib.auth import authenticate, login  # new\n\n# ...\nclass SignUpView(CreateView):\n    model = User\n    fields = [\"username\", \"email\", \"password\"]\n    template_name = \"signup.html\"\n    success_url = reverse_lazy(\"home\")\n\n    def form_valid(self, form):  # new\n        # create the User object\n        user = form.save(commit=False)  # new\n        # set password manually\n        # as otherwise the User will be saved with unhashed password\n        password = form.cleaned_data.get(\"password\")  # new\n        user.set_password(password)  # new\n        # save the User object to the database\n        user.save()  # new\n        # authenticate your user with unhashed password\n        # (`authenticate` expects unhashed passwords)\n        email = form.cleaned_data.get(\"email\")  # new\n        authenticated_user = authenticate(email=email, password=password)  # new\n        # log in\n        login(self.request, authenticated_user)  # new\n        return redirect(self.success_url)  # new\n</code></pre> <p>To make sure you understand what we're doing here: Django hashes passwords when creating a new <code>User</code>, but we need to make it explicit that the <code>password</code> field is the password (through <code>user.set_password(password)</code>) and needs to be hashed, otherwise there will be errors whenever we try to authenticate:</p> <ul> <li>Django will save the unhashed password to the database</li> <li>during login, it will take the user-submitted plaintext password and hash it</li> <li>check the hash of the user-submitted password against what it believes to be the hash of the actual password in the database</li> <li>see that the two passwords don't match (obviously)</li> <li>refuse authentication.</li> </ul> <p>Now that we've resolved the issue, try creating a new user: everything should work.</p>"},{"location":"10_profile_features/","title":"Profile features","text":""},{"location":"10_profile_features/#introduction","title":"Introduction","text":"<p>Profile features are a central part of our app: users should be able to customize their profile, to visit other profiles, and to view the articles written by a given user.</p>"},{"location":"10_profile_features/#viewing-profiles","title":"Viewing Profiles","text":"<p>It's time to allow users to view their own and other users' profiles.</p> <p>In <code>users/views.py</code>:</p> <pre><code># ...\nfrom django.views.generic import CreateView, DetailView\n\n# ...\nclass ProfileDetailView(DetailView):\n    model = User\n    template_name = \"profile_detail.html\"\n</code></pre> <p>In <code>users/urls.py</code>:</p> <pre><code># ...\nfrom .views import Login, Logout, SignUpView, ProfileDetailView\n\n\nurlpatterns = [\n    # ...\n    path(\"profile/@&lt;str:username&gt;\", ProfileDetailView.as_view(), name=\"profile_detail\"),\n]\n</code></pre> <p>In the <code>templates</code> folder, create <code>profile_detail.html</code>:</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n    &lt;title&gt;{{ profile.user.username }} - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n    &lt;div class=\"profile-page\"&gt;\n        &lt;div class=\"user-info\"&gt;\n            &lt;div class=\"container\"&gt;\n                &lt;div class=\"row\"&gt;\n                    &lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n                        &lt;img src=\"{{ profile.image }}\" class=\"user-img\" alt=\"{{ profile.user.username }}\" /&gt;\n                        &lt;h4&gt;{{ profile.user.username }}&lt;/h4&gt;\n                        &lt;p&gt;{{ profile.bio|default:\"This user doesn't have a bio for now\" }}&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>Everything should be working now, right? Let's check by going to <code>localhost:8000/profile/@admin</code>, for example. Welp, we're getting an error:</p> profile_detail error <p>The error tells us that our <code>ProfileDetailView</code> wants to be called with an object primary key or a slug, while we're calling it with a <code>username</code>. The solution is simple: we just change how the view decides which objects to show.</p> <p>We override the view's <code>get_object</code> method by adding the following to <code>users/views.py</code>:</p> <pre><code># ...\nfrom django.shortcuts import redirect, get_object_or_404\n\n# ...\nclass ProfileDetailView(DetailView):\n    model = Profile\n    template_name = \"profile_detail.html\"\n\n    def get_object(self, queryset=None):                                  # new\n        username = self.kwargs.get(\"username\", None)                    # new\n        profile = get_object_or_404(User, username=username).profile    # new\n        return profile                                                  # new\n</code></pre> <p>Let's try again: we should see an actual profile page (though there isn't much on it yet). Make sure to set a profile image for your <code>admin</code> user, as everyone else should have a default already set.</p> A view of a profile, sans errors"},{"location":"10_profile_features/#viewing-articles-written-by-each-user","title":"Viewing Articles written by each User","text":"<p>Whenever we visit a user's profile, we want to see all the articles written by that specific user. We could make a <code>ListView</code>, but passing the list to our <code>DetailView</code>'s context is simpler.</p> <p>In <code>users/views.py</code>, override the <code>get_context_data</code> method of <code>ProfileDetailView</code>:</p> <pre><code># ...\nclass ProfileDetailView(DetailView):\n    # ...\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        if self.request.user.is_authenticated:\n            context[\"my_articles\"] = self.object.articles.order_by('-created_at')\n        return context\n</code></pre> <p>This will return all the articles written by the user whose username is specified in the URL: for example, <code>/profile/@admin</code> will return all the articles written by <code>admin</code>. Technically, we could have obtained this queryset directly in the template with something like <code>{{ profile.articles.order_by|dictsortreversed:\"created_at\" }}</code>, but dealing with logic in views makes for clearer code and easier debugging.</p> <p>Expose the <code>article_list.html</code> template in <code>templates/profile_detail.html</code>:</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n    &lt;title&gt;{{ profile.user.username }} - Conduit: Django + HTMX&lt;/title&gt;\n{% endblock %}\n{% block content %}\n    &lt;div class=\"profile-page\"&gt;\n        &lt;div class=\"user-info\"&gt;\n            &lt;div class=\"container\"&gt;\n                &lt;div class=\"row\"&gt;\n                    &lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n                        &lt;img src=\"{{ profile.image }}\" class=\"user-img\" alt=\"{{ profile.user.username }}\" /&gt;\n                        &lt;h4&gt;{{ profile.user.username }}&lt;/h4&gt;\n                        &lt;p&gt;{{ profile.bio|default:\"This user doesn't have a bio for now\" }}&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"container\"&gt;                 &lt;!-- new from here --&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n                    &lt;div class=\"articles-toggle\"&gt;\n                        &lt;ul class=\"nav nav-pills outline-active\"&gt;\n                            &lt;li class=\"nav-item\"&gt;\n                                &lt;span class=\"nav-link\"&gt;\n                                  My Articles\n                                &lt;/span&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n                    {% include 'article_list.html' with articles=my_articles %}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;                                  &lt;!-- new to here --&gt;\n    &lt;/div&gt;\n{% endblock %}\n</code></pre>"},{"location":"10_profile_features/#links-to-profiles-in-templates","title":"Links to Profiles in templates","text":"<p>We now need to link the profile page from all the places our users' usernames are exposed.</p> <p>In <code>templates/article_preview.html</code>, change the following lines:</p> <pre><code>&lt;div class=\"article-meta\"&gt;\n  &lt;a href=\"{% url 'profile_detail' username=article.author.user.username %}\"&gt;                   &lt;!-- new --&gt;\n    &lt;img src=\"{{ article.author.image }}\" alt=\"{{ article.author.user.username }}\"/&gt;            &lt;!-- new --&gt;\n  &lt;/a&gt;                                                                                          &lt;!-- new --&gt;\n  &lt;div class=\"info\"&gt;\n    &lt;a href=\"{% url 'profile_detail' username=article.author.user.username %}\" class=\"author\"&gt;  &lt;!-- from &lt;span class=\"author\"&gt; --&gt;\n        {{ article.author.user.username }}\n    &lt;/a&gt;                                                                                        &lt;!-- from &lt;/span&gt; --&gt;\n    &lt;span class=\"date\"&gt;\n      {{ article.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>In <code>templates/nav.html</code>:</p> <pre><code>{% if user.is_authenticated %}\n  &lt;li class=\"nav-item\"&gt;\n    {% url 'editor_create' as editor_create %}\n    &lt;a\n      href=\"{{ editor_create }}\"\n      rel=\"prefetch\"\n      class=\"nav-link\n             {% if request.path == editor_create %}active{% endif %}\"\n    &gt;\n      &lt;span class=\"ion-compose\"&gt; New Post &lt;/span&gt;\n    &lt;/a&gt;\n  &lt;/li&gt;\n  &lt;li class=\"nav-item\"&gt;                             &lt;!-- new from here --&gt;\n    {% url 'profile_detail' username=user.username as profile %}\n    &lt;a\n      href=\"{{ profile }}\"\n      rel=\"prefetch\"\n      class=\"nav-link\n             {% if request.path == profile %}active{% endif %}\"\n    &gt;\n      &lt;img src=\"{{ user.profile.image }}\" class=\"user-pic\" alt=\"{{ user.username }}\"&gt;\n      {{ user.username }}\n    &lt;/a&gt;\n  &lt;/li&gt;                                             &lt;!-- new to here --&gt;\n  &lt;li class=\"nav-item\"&gt;\n    &lt;a rel=\"prefetch\" href=\"{% url 'logout' %}\" class=\"nav-link\"&gt;\n      &lt;span class=\"ion-log-out\"&gt;&lt;/span&gt;\n    &lt;/a&gt;\n  &lt;/li&gt;\n{% else %}\n</code></pre> <p>In <code>templates/article_detail.html</code>:</p> <pre><code>&lt;div class=\"article-meta\"&gt;\n  &lt;a href=\"{% url 'profile_detail' username=article.author.user.username %}\"&gt;                  &lt;!-- new --&gt;\n    &lt;img src=\"{{ article.author.image }}\" alt=\"{{ article.author.user.username }}\"/&gt;           &lt;!-- new --&gt;\n  &lt;/a&gt;                                                                                         &lt;!-- new --&gt;\n  &lt;div class=\"info\"&gt;\n    &lt;a href=\"{% url 'profile_detail' username=article.author.user.username %}\" class=\"author\"&gt; &lt;!-- from &lt;span class=\"author\"&gt; --&gt;\n      {{ article.author.user.username }}\n    &lt;/a&gt;                                                                                       &lt;!-- from &lt;/span&gt; --&gt;\n    &lt;span class=\"date\"&gt;\n      {{ article.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n  &lt;/div&gt;\n</code></pre> <p>In <code>templates/comment_container.html</code>:</p> <pre><code>&lt;div class=\"card-footer\"&gt;\n  &lt;a href=\"{% url 'profile_detail' username=comment.author.user.username %}\" class=\"comment-author\"&gt;            &lt;!-- new --&gt;\n    &lt;img src=\"{{ comment.author.image }}\" class=\"comment-author-img\" alt=\"{{ comment.author.user.username }}\"/&gt; &lt;!-- new --&gt;\n  &lt;/a&gt;                                                                                                          &lt;!-- new --&gt;\n  &lt;a href=\"{% url 'profile_detail' username=comment.author.user.username %}\" class=\"comment-author\"&gt;            &lt;!-- from &lt;span class=\"comment-author\"&gt; --&gt;\n      {{ comment.author.user.username }}\n  &lt;/a&gt;                                                                                                          &lt;!-- from &lt;/span&gt;--&gt;\n  &lt;span class=\"date-posted\"&gt;\n    {{ comment.created_at|date:\"D M d Y\" }}\n  &lt;/span&gt;\n  {% include 'comment_delete.html' %}\n&lt;/div&gt;\n</code></pre>"},{"location":"11_editing_profiles/","title":"Editing profiles","text":""},{"location":"11_editing_profiles/#introduction","title":"Introduction","text":"<p>We want to allow users to modify their profile information (image, bio) and user information (username, email, password) at the same place. That is, we want to allow users to update two models at the same URL. Surprisingly, this common use case is not straightforward to implement with Django, especially if we're trying to follow good practice and use class-based views. Take a break before continuing, as we're going to go into the weeds here.</p> <p>Cool, let's recap what we're doing. We have two models (<code>User</code> and <code>Profile</code>), which happen to be related with a <code>OneToOneField</code>. We want to update these models in one place. Intuitively, we'll reach for the <code>UpdateView</code>. The problem is that <code>UpdateView</code> expects a single model. The solution is to tell our <code>UpdateView</code> to deal with two forms.</p>"},{"location":"11_editing_profiles/#forms","title":"Forms","text":"<p>Let's create <code>users/forms.py</code> and define two forms, one for each model:</p> <pre><code>from django import forms\nfrom django.contrib.auth import get_user_model\nfrom .models import Profile\n\n\nclass ProfileForm(forms.ModelForm):\n    class Meta:\n        model = Profile\n        fields = [\"image\", \"bio\"]\n\n\nclass UserForm(forms.ModelForm):\n    new_password = forms.CharField(required=False)\n\n    class Meta:\n        model = get_user_model()\n        fields = [\"username\", \"email\", \"new_password\"]\n\n    def save(self, commit=True):\n        user = super().save(commit=False)\n        new_password = self.cleaned_data.get(\"new_password\")\n        if new_password:\n            user.set_password(new_password)\n        user.save()\n        return user\n</code></pre> <p><code>ModelForm</code> allows to get a lot of model-relevant form logic for free (Django's \u201cbatteries included\u201d philosophy).</p> <p>The <code>ProfileForm</code> is self-explanatory.</p> <p>The <code>UserForm</code> is a bit more complicated. Let's go through it in detail. We want our user to be able to update three types of information: the username, the email, and the password. We also want to expose the current username and email values in the template, but we don't want to expose any information about the password. The screenshot below clarifies what we mean here: the screenshot on the right could leak information about the number of characters in our user's password, even though the characters themselves are masked, while the screenshot on the right exposes no information about the password.</p> Password field with masked characters Empty password field <p>We want the password field in our future template to be empty, and we don't want to force the user to type it out every time they want to modify some other information. In other words, we want the password field to be optional, i.e. <code>required=False</code>. Furthermore, since this password field doesn't need any information about the current password, we can just create a dummy <code>new_password</code> field, instead of linking our form to the <code>User</code> model's actual <code>password</code> attribute. Finally, when we save the form, we only want to update the password if the user has actually changed it on the form, so we need to override the form's <code>save</code> method. Also, because Django saves hashes of passwords, instead of the raw password strings, in its database, we need to use the <code>User</code> object's <code>set_password</code> method, which takes care of the password hashing.</p>"},{"location":"11_editing_profiles/#views","title":"Views","text":"<p>Now that our forms are ready, let's create the view. As we said earlier, the intuitive choice here is the generic <code>UpdateView</code> class-based view.</p> <pre><code># ...\nfrom django.views.generic import CreateView, DetailView, UpdateView\nfrom django.contrib.auth.mixins import LoginRequiredMixin\n\n# ...\nclass ProfileUpdateView(LoginRequiredMixin, UpdateView):\n    form_class = ProfileForm\n    template_name = \"settings.html\"\n    success_url = reverse_lazy(\"settings\")\n\n    def get_object(self, queryset=None):\n        return self.request.user.profile\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"user_form\"] = UserForm(instance=self.request.user)\n        return context\n\n    def post(self, request, *args, **kwargs):\n        profile_form = self.form_class(request.POST, instance=request.user.profile)\n        user_form = UserForm(request.POST, instance=request.user)\n        if profile_form.is_valid() and user_form.is_valid():\n            profile_form.save()\n            user_form.save()\n            return redirect(self.success_url)\n        return super().post(request, *args, **kwargs)\n</code></pre> <p>Again, this is a significant amount of code, so let's go through it slowly.</p> <p>Only logged-in users should be able to edit their profile information, hence the <code>LoginRequiredMixin</code>.</p> <p><code>UpdateView</code> expects to deal with a single form by default, and every form requires a queryset, and some explicitly-defined <code>fields</code> or <code>form_class</code>. However, we want our <code>UpdateView</code> to deal with two forms: we will pass one form to the view in the way it expects, and the other we will pass as extra context data. We tell our <code>UpdateView</code> that its (official) form will be of the class <code>ProfileForm</code> and that its queryset will be a single instance of the <code>Profile</code> model: namely, the users will only be able to update their own profile (hence the <code>get_object</code> override). The additional form that <code>ProfileUpdateView</code> needs to deal with will be of class <code>UserForm</code> and will have <code>self.request.user</code> as its queryset. We also tell <code>ProfileUpdateView</code> that we'll want to refer to this form by <code>user_form</code> in our template. Finally, we need to process the two forms, which means that we need to override <code>UpdateView</code>'s <code>post</code> method. We take our whole <code>POST</code> request and run it through both <code>ProfileForm</code> and <code>UserForm</code>: this means that we let the forms take in the whole of the data, pick what they need (i.e. what corresponds to their fields), and apply it to the relevant objects. If our forms are valid, we can save the information. Otherwise, we reject the input (and re-render everything with relevant error information).</p>"},{"location":"11_editing_profiles/#templates","title":"Templates","text":"<p>In <code>templates/settings.html</code>:</p> <pre><code>{% extends 'base.html' %}\n{% block title %}\n  &lt;title&gt;Settings - Conduit&lt;/title&gt;\n{% endblock %}\n{% block content %}\n  &lt;div class=\"settings-page\"&gt;\n    &lt;div class=\"container page\"&gt;\n      &lt;div class=\"row\"&gt;\n        &lt;div class=\"col-md-6 offset-md-3 col-xs-12\"&gt;\n          &lt;h1 class=\"text-xs-center\"&gt;Your Settings&lt;/h1&gt;\n          &lt;form method=\"post\"&gt;\n            {% csrf_token %}\n            &lt;fieldset&gt;\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control\"\n                  type=\"text\"\n                  placeholder=\"URL of profile picture\"\n                  name=\"{{ form.image.name }}\"\n                  value=\"{{ form.image.value|default_if_none:'' }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ form.image.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control form-control-lg\"\n                  type=\"text\"\n                  required\n                  placeholder=\"Username\"\n                  name=\"{{ user_form.username.name }}\"\n                  value=\"{{  user_form.username.value|default_if_none:'' }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ user_form.username.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;textarea\n                  class=\"form-control form-control-lg\"\n                  rows=\"8\"\n                  placeholder=\"Short bio about you\"\n                  name=\"{{ form.bio.name }}\"\n                &gt;{{ form.bio.value|default_if_none:'' }}&lt;/textarea&gt;\n              &lt;/fieldset&gt;\n              {{ form.bio.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control form-control-lg\"\n                  type=\"email\"\n                  placeholder=\"Email\"\n                  required\n                  name=\"{{ user_form.email.name }}\"\n                  value=\"{{ user_form.email.value|default_if_none:'' }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ user_form.email.errors }}\n              &lt;fieldset class=\"form-group\"&gt;\n                &lt;input\n                  class=\"form-control form-control-lg\"\n                  type=\"password\"\n                  placeholder=\"New Password\"\n                  name=\"{{ user_form.new_password.name }}\"\n                /&gt;\n              &lt;/fieldset&gt;\n              {{ user_form.new_password.errors }}\n              &lt;button class=\"btn btn-lg btn-primary pull-xs-right\" type=\"submit\"&gt;\n                Update Settings\n              &lt;/button&gt;\n            &lt;/fieldset&gt;\n          &lt;/form&gt;\n          &lt;hr /&gt;\n          &lt;a href=\"{% url 'logout' %}\" class=\"btn btn-outline-danger\"&gt;\n            Or click here to logout.\n          &lt;/a&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre> <p>The template is quite simple, for a change: we refer to the <code>ProfileUpdateView</code>'s main form by <code>form</code>, and to the additional form by <code>user_form</code>.</p> <p>Finally, let's specify a URL to <code>settings</code> and add a link in the navbar and in each individual profile.</p> <p>In <code>users/urls.py</code>:</p> <pre><code># ...\nfrom .views import Login, Logout, SignUpView, ProfileDetailView, ProfileUpdateView\n\n\nurlpatterns = [\n    # ...\n    path(\"settings/\", ProfileUpdateView.as_view(), name=\"settings\"),\n]\n</code></pre> <p>In <code>templates/nav.html</code>:</p> <pre><code>&lt;li class=\"nav-item\"&gt;\n  &lt;a rel=\"prefetch\" href=\"{% url 'editor_create' %}\" class=\"nav-link\"&gt;\n    &lt;span class=\"ion-compose\"&gt; New Post &lt;/span&gt;\n  &lt;/a&gt;\n&lt;/li&gt;\n&lt;li class=\"nav-item\"&gt;\n  {% url 'settings' as settings %}\n  &lt;a\n    href=\"{{ settings }}\"\n    rel=\"prefetch\"\n    class=\"nav-link\n           {% if request.path == settings %}active{% endif %}\"\n  &gt;\n    &lt;span class=\"ion-gear-a\"&gt; Settings &lt;/span&gt;\n  &lt;/a&gt;\n&lt;/li&gt;\n&lt;li class=\"nav-item\"&gt;\n  &lt;a rel=\"prefetch\" href=\"{% url 'profile_detail' username=user.username %}\" class=\"nav-link\"&gt;\n    &lt;img src=\"{{ user.profile.image }}\" class=\"user-pic\" alt=\"{{ user.username }}\"&gt;\n    {{ user.username }}\n  &lt;/a&gt;\n&lt;/li&gt;\n</code></pre> <p>In <code>templates/profile_detail.html</code>:</p> <pre><code>&lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n  &lt;img src=\"{{ profile.image }}\" class=\"user-img\" alt=\"{{ profile.user.username }}\" /&gt;\n  &lt;h4&gt;{{ profile.user.username }}&lt;/h4&gt;\n  &lt;p&gt;{{ profile.bio|default:\"This user doesn't have a bio for now\" }}&lt;/p&gt;\n  {% if user.username == profile.user.username %}   &lt;!-- new from here --&gt;\n    &lt;a\n      href=\"{% url 'settings' %}\"\n      class=\"btn btn-sm btn-outline-secondary action-btn\"\n    &gt;\n      &lt;span class=\"ion-gear-a\"&gt;\n        Edit Profile Settings\n      &lt;/span&gt;\n    &lt;/a&gt;\n  {% endif %}                                       &lt;!-- new to here --&gt;\n&lt;/div&gt;\n</code></pre> <p>We should add that all of this would have been much easier if we had a single model dealing with <code>User</code> and <code>Profile</code> information, instead of separating the two (as we could have kept a generic <code>UpdateView</code>), but that would have gone against best practice. Similarly, our task would have been simplified if <code>User</code> and <code>Profile</code> were related through a <code>ForeignKey</code> (as we could have used inline formsets), but that would have gone against common patterns in Django.</p>"},{"location":"12_follows/","title":"Follows","text":""},{"location":"12_follows/#introduction","title":"Introduction","text":"<p>In this chapter, we'll let users follow other users, so that they can keep abreast of their favourite users' articles.</p>"},{"location":"12_follows/#creating-a-few-new-users-and-articles","title":"Creating a few new users and articles","text":"<p>To make the following sections more interesting, let's create a new users and posts. Run Django shell with <code>(django) django_tutorial$ python manage.py shell</code> and then paste the following into your shell (no need to clean it):</p> <pre><code>In [1]: from django.contrib.auth import get_user_model\nIn [2]: from conduit.users.models import Profile\nIn [3]: from conduit.articles.models import Article\nIn [4]: from faker import Faker\nIn [5]: fake = Faker()\nIn [6]: fake.seed_instance(42)\nIn [7]: for i in range(2):\n   ...:     user = get_user_model().objects.create_user(username=fake.user_name(), email=fake.email(), password=fake.password())\n   ...:     profile = user.profile\n   ...:     profile.image = fake.image_url(600, 600)\n   ...:     profile.bio = fake.text()\n   ...:     user.save()\n   ...:     for j in range(2):\n   ...:         Article.objects.create(\n   ...:             author=Profile.objects.last(),\n   ...:             title=fake.sentence(),\n   ...:             description=fake.paragraph(),\n   ...:             body=fake.text()\n   ...:         )\n   ...:\nIn [8]: get_user_model().objects.get(username='admin').profile.follow(Profile.objects.last())\n</code></pre> <p>This will create two users with full profiles and a couple articles each.</p>"},{"location":"12_follows/#model","title":"Model","text":"<p>We'll now let our users follow other users, i.e. subscribe to other users' articles. This should be a relationship between <code>Profile</code> objects, where one <code>Profile</code> object can follow, and be followed by, many other <code>Profile</code> objects: we'll use a <code>ManyToManyField</code> relationship.</p> <p>We need a new field in our <code>Profile</code> model in <code>users/models.py</code>:</p> <pre><code># ...\nclass Profile(models.Model):\n    # ...\n    follows = models.ManyToManyField(\n        \"self\", related_name=\"followed_by\", symmetrical=False, blank=True\n    )\n    # ...\n</code></pre> <p>The args we pass to the <code>ManyToManyField</code> signify that the relationship works between <code>Profile</code> objects, that we can get the <code>Profile</code> objects followed by a given <code>Profile</code> with the <code>follows</code> attribute, that we can know who's following a given <code>Profile</code> with the <code>followed_by</code> attribute, and that follows are a one-way relationship (it's not because User A follows User B that User B necessarily follows User A).</p> <p>We also need to define a few methods that will be helpful later on. In <code>users/models.py</code>:</p> <pre><code>class Profile(models.Model):\n    # ...\n    def follow(self, profile):\n        \"\"\"Follow `profile`\"\"\"\n        self.follows.add(profile)\n\n    def unfollow(self, profile):\n        \"\"\"Unfollow `profile`\"\"\"\n        self.follows.remove(profile)\n\n    def is_following(self, profile):\n        \"\"\"Return True if `profile` is in self.follows, False otherwise\"\"\"\n        return self.follows.filter(pk=profile.pk).exists()\n</code></pre> <p>Let's <code>makemigrations</code> and <code>migrate</code>, since we have modified the model.</p> <pre><code>(django) django_tutorial$ python manage.py makemigrations\n# ...\n(django) django_tutorial$ python manage.py migrate\n# ...\n</code></pre>"},{"location":"12_follows/#profiledetailview","title":"ProfileDetailView","text":"<p>We need to let users follow or unfollow other users in our templates. This involves some work around checking whether the user is already in our <code>follows</code> or not. Because the Django Template Language (intentionally) makes it difficult to write non-trivial queries within templates, we'll have to do some groundwork in our views, with the help of the model methods we just created.</p> <p>In <code>users/views.py</code>, we add <code>is_following</code> to the context of <code>ProfileDetailView</code> to enable our template to know whether the authenticated user follows a given profile:</p> <pre><code>class ProfileDetailView(DetailView):\n    # ...\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        if self.request.user.is_authenticated:\n            context[\"my_articles\"] = self.object.articles.order_by('-created_at')\n            context[\"is_following\"] = self.object.is_following(self.object)     # new\n        return context\n</code></pre> <p>Still in <code>users/views.py</code>, we add a RedirectView whose only purpose is to follow or unfollow a profile, depending on whether or not the profile is followed already.</p> <p>In <code>users/urls.py</code>:</p> <pre><code># ...\nfrom .views import (\n    # ...\n    ProfileFollowView,\n)\n\n\nurlpatterns = [\n    # ...\n    path(\n        \"profile/@&lt;str:username&gt;/follow\",\n        ProfileFollowView.as_view(),\n        name=\"profile_follow\",\n    ),\n]\n</code></pre> <p>Let's implement the <code>follow</code> functionality in <code>templates/profile_detail.html</code> now:</p> <pre><code>&lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n  &lt;img src=\"{{ profile.image }}\" class=\"user-img\" alt=\"{{ profile.user.username }}\" /&gt;\n  &lt;h4&gt;{{ profile.user.username }}&lt;/h4&gt;\n  &lt;p&gt;{{ profile.bio|default:\"This user doesn't have a bio for now\" }}&lt;/p&gt;\n  {% if user.username == profile.user.username %}\n    &lt;a\n      href=\"{% url 'settings' %}\"\n      class=\"btn btn-sm btn-outline-secondary action-btn\"\n    &gt;\n      &lt;span class=\"ion-gear-a\"&gt;\n        Edit Profile Settings\n      &lt;/span&gt;\n    &lt;/a&gt;\n  {% else %}                                &lt;!-- new --&gt;\n    {% include 'profile_follow.html' %}     &lt;!-- new --&gt;\n  {% endif %}\n&lt;/div&gt;\n</code></pre> <p>Create <code>templates/profile_follow.html</code>:</p> <pre><code>&lt;form\n  method=\"post\"\n  action=\"{% url 'profile_follow' username=profile.user.username %}\"\n&gt;\n  {% csrf_token %}\n  &lt;button class=\"btn btn-sm action-btn\n                 {% if is_following %}\n                 btn-secondary\n                 {% else %}\n                 btn-outline-secondary\n                 {% endif %}\"\n  &gt;\n    &lt;span class=\"ion-plus-round\"&gt;\n      {% if is_following %}Unfollow{% else %}Follow{% endif %} {{ profile.user.username }}\n    &lt;/span&gt;\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>What we're doing in this template is the following:</p> <ul> <li>if the user's viewing their own profile, show a link to the <code>settings</code> URL.</li> <li>if the user's viewing another profile (or is not logged in), redirect them to the <code>profile_follow</code> URL, which toggles a <code>Profile</code> object's <code>follow</code> and <code>unfollow</code> methods</li> <li>adapt the text and UI based on whether the user's following the viewed profile via a bunch of <code>{% if ...%}</code> template tags.</li> </ul>"},{"location":"12_follows/#articledetailview","title":"ArticleDetailView","text":"<p>We also expose the follow/unfollow feature on article pages.</p> <p>In <code>articles/views.py</code>:</p> <pre><code>class ArticleDetailView(DetailView):\n    # ...\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"form\"] = CommentCreateView().get_form_class()\n        if self.request.user.is_authenticated:\n            context[\"is_following\"] =   self.request.user.profile.is_following(\n                self.object.author\n            )\n        return context\n</code></pre> <p>In <code>templates/article_detail.html</code>:</p> <pre><code>{% if user == article.author.user %}\n  &lt;span&gt;\n    &lt;a\n      href=\"{% url 'editor_update' slug_uuid=article.slug_uuid %}\"\n      class=\"btn btn-outline-secondary btn-sm\"\n    &gt;\n      &lt;span class=\"ion-edit\"&gt;\n        Edit Article\n      &lt;/span&gt;\n    &lt;/a&gt;\n    {% include 'article_delete.html' %}\n  &lt;/span&gt;\n{% else %}                                                          &lt;!-- new --&gt;\n  &lt;span&gt;                                                            &lt;!-- new --&gt;\n    {% include 'profile_follow.html' with profile=article.author %} &lt;!-- new --&gt;\n  &lt;/span&gt;                                                           &lt;!-- new --&gt;\n{% endif %}\n</code></pre> <p>In <code>templates/profile_follow.html</code>, we add <code>style=\"display:inline\"</code>:</p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'profile_follow' username=profile.user.username %}\"\n    style=\"display:inline\"\n&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>An interesting aside: for the longest time, I tried to follow or unfollow a profile based on whether the template form had <code>method=\"post\"</code> or <code>method=\"delete\"</code> (because <code>RedirectView</code> has both <code>post</code> and <code>delete</code> methods), only to discover that HTML forms only support <code>GET</code> and <code>POST</code> and that workarounds are not very pretty. Live and learn.</p>"},{"location":"12_follows/#redirect-url","title":"Redirect URL","text":"<p>If you play around with the <code>Follow</code> feature, you will notice that it redirects us to the profile page of the user we want to (un)follow. This is due to the fact that the <code>Follow</code> button is exposed both in <code>profile_detail.html</code> and in <code>home.html</code> (through <code>article_preview.html</code>), so for the sake of simplicity we chose a single redirect URL in our <code>ProfileFollowView</code>.</p> <p>However, it would be better if we could stay on whatever page we are when we follow a user. This involves implementing the <code>next</code> kwarg.</p> <p>In <code>templates/profile_follow.html</code>:</p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'profile_follow' username=profile.user.username %}\"\n    style=\"display:inline\"\n&gt;\n    &lt;input type=\"hidden\" name=\"next\" value=\"{{ request.path }}\"&gt;    &lt;!-- new --&gt;\n    {% csrf_token %}\n    &lt;button class=\"btn btn-sm action-btn\n                   {% if is_following %}\n                   btn-secondary\n                   {% else %}\n                   btn-outline-secondary\n                   {% endif %}\"\n    &gt;\n        &lt;span class=\"ion-plus-round\"&gt;\n            {% if is_following %}Unfollow{% else %}Follow{% endif %} {{ profile.user.username }}\n        &lt;/span&gt;\n    &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>The <code>next</code> parameter above just holds the URL that the <code>profile_follow</code> URL pattern was called from.</p> <p>In <code>users/views.py</code>:</p> <pre><code>class ProfileFollowView(LoginRequiredMixin, RedirectView):\n    def get_redirect_url(self, *args, **kwargs):\n        url = self.request.POST.get(\"next\", None)\n        if url:\n            return url\n        else:\n            return super().get_redirect_url(*args, **kwargs)\n\n    # ...\n</code></pre> <p>We override the <code>get_redirect_url</code> method of <code>RedirectView</code> so that we go to the URL specified by <code>next</code>, or fall back to <code>profile_detail</code> if for some reason the <code>next</code> parameter is missing (for example, if the user visits <code>profile_follow</code> directly by typing <code>.../profile/@&lt;username&gt;/follow</code> in their browser's URL bar).</p>"},{"location":"12_follows/#feeds","title":"Feeds","text":"<p>We need to go back all the way to the beginning for this one.</p> <p>In <code>articles/views.py</code>, we need to modify our very first view, <code>home</code>, so that it can give us a feed of articles written by users we follow:</p> <pre><code>class Home(ListView):\n    # ...\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"global_feed\"] = Article.objects.order_by(\"-created_at\")\n        if self.request.user.is_authenticated:                      # new from here\n            context[\"your_articles\"] = Article.objects.filter(\n                author__in=self.request.user.profile.follows.all()\n            ).order_by(\"-created_at\")\n        else:\n            context[\"your_articles\"] = None                         # new to here\n        return context\n</code></pre> <p>In <code>templates/home.html</code>:</p> <pre><code>&lt;div class=\"container page\"&gt;\n  &lt;div class=\"row\"&gt;\n    &lt;div class=\"col-md-9\"&gt;\n      &lt;div class=\"feed-toggle\"&gt;                 &lt;!-- new from here--&gt;\n        &lt;ul class=\"nav nav-pills outline-active\"&gt;\n          &lt;li class=\"nav-item\"&gt;\n            {% url 'home' as home %}\n            &lt;a\n              href=\"{{ home }}\"\n              rel=\"prefetch\"\n              class=\"nav-link\n                     {% if request.path == home %}active{% endif %}\"\n            &gt;\n              Global Feed\n            &lt;/a&gt;\n          &lt;/li&gt;\n          {% if user.is_authenticated %}\n            &lt;li class=\"nav-item\"&gt;\n              {% url 'home_feed' as home_feed %}\n              &lt;a\n                href=\"{{ home_feed }}\"\n                rel=\"prefetch\"\n                class=\"nav-link\n                       {% if request.path == home_feed %}active{% endif %}\"\n              &gt;\n                Your Feed\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% else %}\n            &lt;li class=\"nav-item\"&gt;\n              &lt;a href=\"{% url 'login' %}\" rel=\"prefetch\" class=\"nav-link\"&gt;\n                Sign in to see your Feed\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endif %}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n      {% if request.path == home %}\n        {% include 'article_list.html' with articles=your_articles %}\n      {% elif request.path == home_feed %}\n        {% include 'article_list.html' with articles=global_feed %}\n      {% endif %}                               &lt;!-- new to here --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>In <code>articles/urls.py</code>:</p> <pre><code>urlpatterns = [\n    # ...\n    path(\"feed\", Home.as_view(), name=\"home_feed\"),\n]\n</code></pre>"},{"location":"13_favourites/","title":"Favourites","text":""},{"location":"13_favourites/#introduction","title":"Introduction","text":"<p>What if a user wants to bookmark a masterpiece of an article and come back to it every once in a while? We'll enable our users to favourite specific articles.</p>"},{"location":"13_favourites/#model","title":"Model","text":"<p>The second to last feature we need is allowing users to favourite some articles, so that they are added to the user's profile for everyone to see.</p> <p>In <code>users/models.py</code>:</p> <pre><code>class Profile(models.Model):\n    # ...\n    favorites = models.ManyToManyField(\n        \"articles.Article\", related_name=\"favorited\", blank=True\n    )\n    # ...\n    def favorite(self, article):\n        \"\"\"Add article to Favorites\"\"\"\n        self.favorites.add(article)\n\n    def unfavorite(self, article):\n        \"\"\"Remove article from Favorites\"\"\"\n        self.favorites.remove(article)\n\n    def has_favorited(self, article):\n        \"\"\"Return True if article is in Favorites, False otherwise\"\"\"\n        return self.favorites.filter(pk=article.pk).exists()\n</code></pre>"},{"location":"13_favourites/#articlefavoriteview","title":"ArticleFavoriteView","text":"<p>In <code>articles/views.py</code>:</p> <pre><code>from django.views.generic import (\n    # ...\n    RedirectView\n)\n\n# ...\nclass ArticleFavoriteView(RedirectView):\n    pattern_name = \"article_detail\"\n\n    def get_redirect_url(self, *args, **kwargs):\n        url = self.request.POST.get(\"next\", None)\n        if url:\n            return url\n        else:\n            return super().get_redirect_url(*args, **kwargs)\n\n    def post(self, request, *args, **kwargs):\n        slug_uuid = self.kwargs.get(\"slug_uuid\", None)\n        article = get_object_or_404(Article, slug_uuid=slug_uuid)\n        if request.user.profile.has_favorited(article):\n            request.user.profile.unfavorite(article)\n        else:\n            request.user.profile.favorite(article)\n        return super().post(request, *args, **kwargs)\n</code></pre> <p>In <code>articles/urls.py</code>:</p> <pre><code># ...\nfrom django.shortcuts import redirect, get_object_or_404\nfrom .views import (\n    # ...\n    ArticleFavoriteView\n)\n\nurlpatterns = [\n    # ...\n    path(\n        \"article/&lt;slug:slug_uuid&gt;/favorite\",\n        ArticleFavoriteView.as_view(),\n        name=\"article_favorite\",\n    ),\n]\n</code></pre>"},{"location":"13_favourites/#articledetailview","title":"ArticleDetailView","text":"<p>We don't need to modify the views for this: the logic can happen in the templates.</p> <p>In <code>templates/article_detail.html</code>:</p> <pre><code>{% if user == article.author.user %}\n  &lt;span&gt;\n    &lt;a\n      href=\"{% url 'editor_update' slug_uuid=article.slug_uuid %}\"\n      class=\"btn btn-outline-secondary btn-sm\"\n    &gt;\n      &lt;span class=\"ion-edit\"&gt;\n        Edit Article\n      &lt;/span&gt;\n    &lt;/a&gt;\n    {% include 'article_delete.html' %}\n  &lt;/span&gt;\n{% else %}\n  &lt;span&gt;\n    {% include 'profile_follow.html' with profile=article.author %}\n    {% include 'article_favorite.html' %}           &lt;!-- new --&gt;\n  &lt;/span&gt;\n{% endif %}\n</code></pre> <p>Create <code>templates/article_favorite.html</code>:</p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'article_favorite' slug_uuid=article.slug_uuid %}\"\n    style=\"display:inline\"\n&gt;\n  &lt;input type=\"hidden\" name=\"next\" value=\"{{ request.path }}\"&gt;\n  {% csrf_token %}\n  &lt;button class=\"btn btn-sm action-btn\n                 {% if article in user.profile.favorites.all %}\n                 btn-primary\n                 {% else %}\n                 btn-outline-primary\n                 {% endif %}\"\n  &gt;\n    &lt;span class=\"ion-heart\"&gt;\n      {% if article in user.profile.favorites.all %}\n        Unfavorite\n      {% else %}\n        Favorite\n      {% endif %} Article ({{ article.favorited_by.count }})\n    &lt;/span&gt;\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>Checking if an article is in a user's <code>favorites</code> should be done in the view (or, even better, the model) instead of the template, but we would have to change our templates' structure and write new views if we wanted to include a <code>Favorite</code> button in the <code>article_preview.html</code> template.</p>"},{"location":"13_favourites/#articlepreviewview","title":"ArticlePreviewView","text":"<p>In <code>templates/article_preview.html</code>:</p> <pre><code>&lt;div class=\"info\"&gt;\n    &lt;a href=\"{% url 'profile_detail' username=article.author.user.username %}\" class=\"author\"&gt;\n        {{ article.author.user.username }}\n    &lt;/a&gt;\n    &lt;span class=\"date\"&gt;\n        {{ article.created_at|date:\"D M d Y\" }}\n    &lt;/span&gt;\n&lt;/div&gt;\n&lt;div class=\"pull-xs-right\"&gt;                 &lt;!-- new --&gt;\n    {% include 'article_favorite.html' %}   &lt;!-- new --&gt;\n&lt;/div&gt;                                      &lt;!-- new --&gt;\n</code></pre> <p>In <code>templates/article_favorite.html</code></p> <pre><code>&lt;form\n    method=\"post\"\n    action=\"{% url 'article_favorite' slug_uuid=article.slug_uuid %}\"\n    style=\"display:inline\"\n&gt;\n  &lt;input type=\"hidden\" name=\"next\" value=\"{{ request.path }}\"&gt;\n  {% csrf_token %}\n  &lt;button class=\"btn btn-sm action-btn\n                 {% if article in user.profile.favorites.all %}\n                 btn-primary\n                 {% else %}\n                 btn-outline-primary\n                 {% endif %}\"\n  &gt;\n    &lt;span class=\"ion-heart\"&gt;\n      {% if request.path|truncatechars:7 == 'article' %}  &lt;!-- new --&gt;\n        {% if article in user.profile.favorites.all %}\n          Unfavorite\n        {% else %}\n          Favorite\n        {% endif %} Article ({{ article.favorited_by.count }})\n      {% else  %}                                         &lt;!-- new --&gt;\n        {{ article.favorited_by.count }}                  &lt;!-- new --&gt;\n      {% endif %}                                         &lt;!-- new --&gt;\n    &lt;/span&gt;\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> Favorite button before Favorite button after"},{"location":"13_favourites/#feeds","title":"Feeds","text":"<p>Now, we need to do something with this <code>Favorite</code> feature: we'll display a user's favorited articles on their profile.</p> <p>In <code>users/views.py</code>:</p> <pre><code>class ProfileDetailView(DetailView):\n    # ...\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        if self.request.user.is_authenticated:\n            context[\"my_articles\"] = self.object.articles.order_by(\"-created_at\")\n            context[\"is_following\"] = self.object.is_following(self.object)\n            context[\"favorited_articles\"] = self.object.favorites.order_by(\"-created_at\")  # new\n        return context\n</code></pre> <p>In <code>users/urls.py</code>:</p> <pre><code>urlpatterns = [\n    # ...\n    path(\n        \"profile/@&lt;str:username&gt;/favorites\",\n        ProfileDetailView.as_view(),\n        name=\"profile_favorites\",\n    ),\n]\n</code></pre> <p>In <code>templates/profile_detail.html</code>:</p> <pre><code>&lt;div class=\"container\"&gt;\n  &lt;div class=\"row\"&gt;\n    &lt;div class=\"col-xs-12 col-md-10 offset-md-1\"&gt;\n      &lt;div class=\"articles-toggle\"&gt;\n        &lt;ul class=\"nav nav-pills outline-active\"&gt;\n          &lt;li class=\"nav-item\"&gt;\n            {% url 'profile_detail' username=profile.user.username as profile_detail %}         &lt;!-- new from here --&gt;\n            &lt;a\n              href=\"{{ profile_detail }}\"\n              rel=\"prefetch\"\n              class=\"nav-link\n                     {% if request.path == profile_detail %}active{% endif %}\"\n            &gt;\n              My Articles\n            &lt;/a&gt;                                                                                &lt;!-- new to here --&gt;\n          &lt;/li&gt;\n          &lt;li class=\"nav-item\"&gt;                                                                 &lt;!-- new from here --&gt;\n            {% url 'profile_favorites' username=profile.user.username as profile_favorites %}\n            &lt;a\n              href=\"{{ profile_favorites }}\"\n              rel=\"prefetch\"\n              class=\"nav-link\n                     {% if request.path == profile_favorites %}active{% endif %}\"\n            &gt;\n              Favorited Articles\n            &lt;/a&gt;\n          &lt;/li&gt;                                                                                 &lt;!-- new to here --&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n      {% if request.path == profile_detail %}                                                   &lt;!-- new --&gt;\n        {% include 'article_list.html' with articles=my_articles %}\n      {% elif request.path == profile_favorites %}                                              &lt;!-- new --&gt;\n        {% include 'article_list.html' with articles=favorited_articles %}                      &lt;!-- new --&gt;\n      {% endif %}                                                                               &lt;!-- new --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"14_tags_coming_soon/","title":"Tags (coming soon)","text":""},{"location":"14_tags_coming_soon/#introduction","title":"Introduction","text":"<p>Tags allow us to organise our content. We'll let our users specify tags for their work.</p>"},{"location":"15_htmx_coming_soon/","title":"HTMX (coming soon)","text":""},{"location":"15_htmx_coming_soon/#introduction","title":"Introduction","text":"<p>Time to make the app reactive. Once we're done with this chapter, you won't see any reason for the bloated frontend frameworks to exist (we're exaggerating, but you get it, right?).</p>"},{"location":"16_future_extensions/","title":"Future extensions","text":"<p>In the future, we might extend this tutorial or add new ones. Here are some of the things we're thinking of implementing.</p> <ul> <li> PostgreSQL</li> <li> Django REST framework</li> <li> Crispy forms</li> <li> Jinja templates</li> </ul>"}]}